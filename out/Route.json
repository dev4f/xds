{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "$ref": "#/definitions/Route",
    "definitions": {
        "Route": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name for the route."
                },
                "match": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteMatch",
                    "additionalProperties": true,
                    "description": "Route matching parameters."
                },
                "route": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteAction",
                    "additionalProperties": true,
                    "description": "Route request to some upstream cluster."
                },
                "redirect": {
                    "$ref": "#/definitions/envoy.config.route.v3.RedirectAction",
                    "additionalProperties": true,
                    "description": "Return a redirect."
                },
                "direct_response": {
                    "$ref": "#/definitions/envoy.config.route.v3.DirectResponseAction",
                    "additionalProperties": true,
                    "description": "Return an arbitrary HTTP response directly, without proxying."
                },
                "filter_action": {
                    "$ref": "#/definitions/envoy.config.route.v3.FilterAction",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] A filter-defined action (e.g., it could dynamically generate the RouteAction). [#comment: TODO(samflattery): Remove cleanup in route_fuzz_test.cc when implemented]"
                },
                "non_forwarding_action": {
                    "$ref": "#/definitions/envoy.config.route.v3.NonForwardingAction",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] An action used when the route will generate a response directly, without forwarding to an upstream host. This will be used in non-proxy xDS clients like the gRPC server. It could also be used in the future in Envoy for a filter that directly generates responses for requests."
                },
                "metadata": {
                    "$ref": "#/definitions/envoy.config.core.v3.Metadata",
                    "additionalProperties": true,
                    "description": "The Metadata field can be used to provide additional information about the route. It can be used for configuration, stats, and logging. The metadata should go under the filter namespace that will need it. For instance, if the metadata is intended for the Router filter, the filter name should be specified as ``envoy.filters.http.router``."
                },
                "decorator": {
                    "$ref": "#/definitions/envoy.config.route.v3.Decorator",
                    "additionalProperties": true,
                    "description": "Decorator for the matched route."
                },
                "typed_per_filter_config": {
                    "additionalProperties": {
                        "properties": {
                            "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                            },
                            "value": {
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "binary",
                                "binaryEncoding": "base64"
                            }
                        },
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "This field can be used to provide route specific per filter config. The key should match the :ref:`filter config name \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name\u003e`. See :ref:`Http filter route specific config \u003carch_overview_http_filters_per_filter_config\u003e` for details. [#comment: An entry's value may be wrapped in a :ref:`FilterConfig\u003cenvoy_v3_api_msg_config.route.v3.FilterConfig\u003e` message to specify additional options.]"
                },
                "request_headers_to_add": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HeaderValueOption"
                    },
                    "type": "array",
                    "description": "Specifies a set of headers that will be added to requests matching this route. Headers specified at this level are applied before headers from the enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on header value syntax, see the documentation on :ref:`custom request headers \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                },
                "request_headers_to_remove": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Specifies a list of HTTP headers that should be removed from each request matching this route."
                },
                "response_headers_to_add": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HeaderValueOption"
                    },
                    "type": "array",
                    "description": "Specifies a set of headers that will be added to responses to requests matching this route. Headers specified at this level are applied before headers from the enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on header value syntax, see the documentation on :ref:`custom request headers \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                },
                "response_headers_to_remove": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Specifies a list of HTTP headers that should be removed from each response to requests matching this route."
                },
                "tracing": {
                    "$ref": "#/definitions/envoy.config.route.v3.Tracing",
                    "additionalProperties": true,
                    "description": "Presence of the object defines whether the connection manager's tracing configuration is overridden by this route specific instance."
                },
                "per_request_buffer_limit_bytes": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum bytes which will be buffered for retries and shadowing. If set, the bytes actually buffered will be the minimum value of this and the listener per_connection_buffer_limit_bytes."
                },
                "stat_prefix": {
                    "type": "string",
                    "description": "The human readable prefix to use when emitting statistics for this endpoint. The statistics are rooted at vhost.\u003cvirtual host name\u003e.route.\u003cstat_prefix\u003e. This should be set for highly critical endpoints that one wishes to get “per-route” statistics on. If not set, endpoint statistics are not generated. The emitted statistics are the same as those documented for :ref:`virtual clusters \u003cconfig_http_filters_router_vcluster_stats\u003e`. .. warning::    We do not recommend setting up a stat prefix for    every application endpoint. This is both not easily maintainable and    statistics use a non-trivial amount of memory(approximately 1KiB per route)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Route",
            "description": "A route is both a specification of how to match a request as well as an indication of what to do next (e.g., redirect, forward, rewrite, etc.). .. attention::   Envoy supports routing on HTTP method via :ref:`header matching   \u003cenvoy_v3_api_msg_config.route.v3.HeaderMatcher\u003e`. [#next-free-field: 20]"
        },
        "envoy.config.core.v3.DataSource": {
            "properties": {
                "filename": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Local filesystem data source."
                },
                "inline_bytes": {
                    "type": "string",
                    "description": "Bytes inlined in the configuration.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "inline_string": {
                    "type": "string",
                    "description": "String inlined in the configuration."
                },
                "environment_variable": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Environment variable data source."
                },
                "watched_directory": {
                    "$ref": "#/definitions/envoy.config.core.v3.WatchedDirectory",
                    "additionalProperties": true,
                    "description": "Watched directory that is watched for file changes. If this is set explicitly, the file specified in the ``filename`` field will be reloaded when relevant file move events occur. .. note::   This field only makes sense when the ``filename`` field is set. .. note::   Envoy only updates when the file is replaced by a file move, and not when the file is   edited in place. .. note::   Not all use cases of ``DataSource`` support watching directories. It depends on the   specific usage of the ``DataSource``. See the documentation of the parent message for   details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Data Source",
            "description": "Data source consisting of a file, an inline value, or an environment variable. [#next-free-field: 6]"
        },
        "envoy.config.core.v3.HeaderValue": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Header name."
                },
                "value": {
                    "type": "string",
                    "description": "Header value. The same :ref:`format specifier \u003cconfig_access_log_format\u003e` as used for :ref:`HTTP access logging \u003cconfig_access_log\u003e` applies here, however unknown header values are replaced with the empty string instead of ``-``. Header value is encoded as string. This does not work for non-utf8 characters. Only one of ``value`` or ``raw_value`` can be set."
                },
                "raw_value": {
                    "type": "string",
                    "description": "Header value is encoded as bytes which can support non-utf8 characters. Only one of ``value`` or ``raw_value`` can be set.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Value",
            "description": "Header name/value pair."
        },
        "envoy.config.core.v3.HeaderValueOption": {
            "properties": {
                "header": {
                    "$ref": "#/definitions/envoy.config.core.v3.HeaderValue",
                    "additionalProperties": true,
                    "description": "Header name/value pair that this option applies to."
                },
                "append": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Should the value be appended? If true (default), the value is appended to existing values. Otherwise it replaces any existing values. This field is deprecated and please use :ref:`append_action \u003cenvoy_v3_api_field_config.core.v3.HeaderValueOption.append_action\u003e` as replacement. .. note::   The :ref:`external authorization service \u003cenvoy_v3_api_msg_service.auth.v3.CheckResponse\u003e` and   :ref:`external processor service \u003cenvoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse\u003e` have   default value (``false``) for this field."
                },
                "append_action": {
                    "enum": [
                        "APPEND_IF_EXISTS_OR_ADD",
                        0,
                        "ADD_IF_ABSENT",
                        1,
                        "OVERWRITE_IF_EXISTS_OR_ADD",
                        2,
                        "OVERWRITE_IF_EXISTS",
                        3
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Header Append Action",
                    "description": "Describes the supported actions types for header append action."
                },
                "keep_empty_value": {
                    "type": "boolean",
                    "description": "Is the header value allowed to be empty? If false (default), custom headers with empty values are dropped, otherwise they are added."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Value Option",
            "description": "Header name/value pair plus option to control append behavior."
        },
        "envoy.config.core.v3.Metadata": {
            "properties": {
                "filter_metadata": {
                    "additionalProperties": {
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*`` namespace is reserved for Envoy's built-in filters. If both ``filter_metadata`` and :ref:`typed_filter_metadata \u003cenvoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata\u003e` fields are present in the metadata with same keys, only ``typed_filter_metadata`` field will be parsed."
                },
                "typed_filter_metadata": {
                    "additionalProperties": {
                        "properties": {
                            "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                            },
                            "value": {
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "binary",
                                "binaryEncoding": "base64"
                            }
                        },
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*`` namespace is reserved for Envoy's built-in filters. The value is encoded as google.protobuf.Any. If both :ref:`filter_metadata \u003cenvoy_v3_api_field_config.core.v3.Metadata.filter_metadata\u003e` and ``typed_filter_metadata`` fields are present in the metadata with same keys, only ``typed_filter_metadata`` field will be parsed."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Metadata provides additional inputs to filters based on matched listeners, filter chains, routes and endpoints. It is structured as a map, usually from filter name (in reverse DNS format) to metadata specific to the filter. Metadata key-values for a filter are merged as connection and request handling occurs, with later values for the same key overriding earlier values. An example use of metadata is providing additional values to http_connection_manager in the envoy.http_connection_manager.access_log namespace. Another example use of metadata is to per service config info in cluster metadata, which may get consumed by multiple filters. For load balancing, Metadata provides a means to subset cluster endpoints. Endpoints have a Metadata object associated and routes contain a Metadata object to match against. There are some well defined metadata used today for this purpose: * ``{\"envoy.lb\": {\"canary\": \u003cbool\u003e }}`` This indicates the canary status of an   endpoint and is also used during header processing   (x-envoy-upstream-canary) and for stats purposes. [#next-major-version: move to type/metadata/v2]"
        },
        "envoy.config.core.v3.ProxyProtocolConfig": {
            "properties": {
                "version": {
                    "enum": [
                        "V1",
                        0,
                        "V2",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Version"
                },
                "pass_through_tlvs": {
                    "$ref": "#/definitions/envoy.config.core.v3.ProxyProtocolPassThroughTLVs",
                    "additionalProperties": true,
                    "description": "This config controls which TLVs can be passed to upstream if it is Proxy Protocol V2 header. If there is no setting for this field, no TLVs will be passed through."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Proxy Protocol Config"
        },
        "envoy.config.core.v3.ProxyProtocolPassThroughTLVs": {
            "properties": {
                "match_type": {
                    "enum": [
                        "INCLUDE_ALL",
                        0,
                        "INCLUDE",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Pass TL Vs Match Type"
                },
                "tlv_type": {
                    "items": {
                        "type": "integer"
                    },
                    "type": "array",
                    "description": "The TLV types that are applied based on match_type. TLV type is defined as uint8_t in proxy protocol. See `the spec \u003chttps://www.haproxy.org/download/2.1/doc/proxy-protocol.txt\u003e`_ for details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Proxy protocol]",
            "description": "[#protodoc-title: Proxy protocol]"
        },
        "envoy.config.core.v3.RuntimeFractionalPercent": {
            "properties": {
                "default_value": {
                    "$ref": "#/definitions/envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "Default value if the runtime value's for the numerator/denominator keys are not available."
                },
                "runtime_key": {
                    "type": "string",
                    "description": "Runtime key for a YAML representation of a FractionalPercent."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime Fractional Percent",
            "description": "Runtime derived FractionalPercent with defaults for when the numerator or denominator is not specified via a runtime key. .. note::   Parsing of the runtime key's data is implemented such that it may be represented as a   :ref:`FractionalPercent \u003cenvoy_v3_api_msg_type.v3.FractionalPercent\u003e` proto represented as JSON/YAML   and may also be represented as an integer with the assumption that the value is an integral   percentage out of 100. For instance, a runtime key lookup returning the value \"42\" would parse   as a ``FractionalPercent`` whose numerator is 42 and denominator is HUNDRED."
        },
        "envoy.config.core.v3.TypedExtensionConfig": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of an extension. This is not used to select the extension, instead it serves the role of an opaque identifier."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The typed config for the extension. The type URL will be used to identify the extension. In the case that the type URL is ``xds.type.v3.TypedStruct`` (or, for historical reasons, ``udpa.type.v1.TypedStruct``), the inner type URL of ``TypedStruct`` will be utilized. See the :ref:`extension configuration overview \u003cconfig_overview_extension_configuration\u003e` for further details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Extension configuration]",
            "description": "[#protodoc-title: Extension configuration]  Message type for extension configuration. [#next-major-version: revisit all existing typed_config that doesn't use this wrapper.]."
        },
        "envoy.config.core.v3.WatchedDirectory": {
            "properties": {
                "path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Directory path to watch."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Watched Directory",
            "description": "A directory that is watched for changes, e.g. by inotify on Linux. Move/rename events inside this directory trigger the watch."
        },
        "envoy.config.route.v3.ClusterSpecifierPlugin": {
            "properties": {
                "extension": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "The name of the plugin and its opaque configuration."
                },
                "is_optional": {
                    "type": "boolean",
                    "description": "If is_optional is not set or is set to false and the plugin defined by this message is not a supported type, the containing resource is NACKed. If is_optional is set to true, the resource would not be NACKed for this reason. In this case, routes referencing this plugin's name would not be treated as an illegal configuration, but would result in a failure if the route is selected."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Cluster Specifier Plugin",
            "description": "Configuration for a cluster specifier plugin."
        },
        "envoy.config.route.v3.CorsPolicy": {
            "properties": {
                "allow_origin_string_match": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher"
                    },
                    "type": "array",
                    "description": "Specifies string patterns that match allowed origins. An origin is allowed if any of the string matchers match."
                },
                "allow_methods": {
                    "type": "string",
                    "description": "Specifies the content for the ``access-control-allow-methods`` header."
                },
                "allow_headers": {
                    "type": "string",
                    "description": "Specifies the content for the ``access-control-allow-headers`` header."
                },
                "expose_headers": {
                    "type": "string",
                    "description": "Specifies the content for the ``access-control-expose-headers`` header."
                },
                "max_age": {
                    "type": "string",
                    "description": "Specifies the content for the ``access-control-max-age`` header."
                },
                "allow_credentials": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Specifies whether the resource allows credentials."
                },
                "filter_enabled": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeFractionalPercent",
                    "additionalProperties": true,
                    "description": "Specifies the % of requests for which the CORS filter is enabled. If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS filter will be enabled for 100% of the requests. If :ref:`runtime_key \u003cenvoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key\u003e` is specified, Envoy will lookup the runtime key to get the percentage of requests to filter."
                },
                "shadow_enabled": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeFractionalPercent",
                    "additionalProperties": true,
                    "description": "Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not enforced. This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those fields have to explicitly disable the filter in order for this setting to take effect. If :ref:`runtime_key \u003cenvoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key\u003e` is specified, Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate and track the request's ``Origin`` to determine if it's valid but will not enforce any policies."
                },
                "allow_private_network_access": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Specify whether allow requests whose target server's IP address is more private than that from which the request initiator was fetched. More details refer to https://developer.chrome.com/blog/private-network-access-preflight."
                },
                "forward_not_matching_preflights": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Specifies if preflight requests not matching the configured allowed origin should be forwarded to the upstream. Default is true."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Cors Policy",
            "description": "Cors policy configuration. .. attention::   This message has been deprecated. Please use   :ref:`CorsPolicy in filter extension \u003cenvoy_v3_api_msg_extensions.filters.http.cors.v3.CorsPolicy\u003e`   as as alternative. [#next-free-field: 14]"
        },
        "envoy.config.route.v3.Decorator": {
            "properties": {
                "operation": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The operation name associated with the request matched to this route. If tracing is enabled, this information will be used as the span name reported for this request. .. note::   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden   by the :ref:`x-envoy-decorator-operation   \u003cconfig_http_filters_router_x-envoy-decorator-operation\u003e` header."
                },
                "propagate": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the decorated details should be propagated to the other party. The default is true."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Decorator"
        },
        "envoy.config.route.v3.DirectResponseAction": {
            "properties": {
                "status": {
                    "type": "integer",
                    "description": "Specifies the HTTP response status to be returned."
                },
                "body": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "Specifies the content of the response body. If this setting is omitted, no body is included in the generated response. .. note::   Headers can be specified using ``response_headers_to_add`` in the enclosing   :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` or   :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Direct Response Action"
        },
        "envoy.config.route.v3.FilterAction": {
            "properties": {
                "action": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Filter Action",
            "description": "A filter-defined action type."
        },
        "envoy.config.route.v3.HeaderMatcher": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Specifies the name of the header in the request."
                },
                "exact_match": {
                    "type": "string",
                    "description": "If specified, header match will be performed based on the value of the header. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`."
                },
                "safe_regex_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`."
                },
                "range_match": {
                    "$ref": "#/definitions/envoy.type.v3.Int64Range",
                    "additionalProperties": true,
                    "description": "If specified, header match will be performed based on range. The rule will match if the request header value is within this range. The entire request header value must represent an integer in base 10 notation: consisting of an optional plus or minus sign followed by a sequence of digits. The rule will not match if the header value does not represent an integer. Match will fail for empty values, floating point numbers or if only a subsequence of the header value is an integer. Examples: * For range [-10,0), route will match for header value -1, but not for 0, ``somestring``, 10.9,   ``-1somestring``"
                },
                "present_match": {
                    "type": "boolean",
                    "description": "If specified as true, header match will be performed based on whether the header is in the request. If specified as false, header match will be performed based on whether the header is absent."
                },
                "prefix_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on the prefix of the header value. Note: empty prefix is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The prefix ``abcd`` matches the value ``abcdxyz``, but not for ``abcxyz``."
                },
                "suffix_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on the suffix of the header value. Note: empty suffix is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The suffix ``abcd`` matches the value ``xyzabcd``, but not for ``xyzbcd``."
                },
                "contains_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on whether the header value contains the given value or not. Note: empty contains match is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The value ``abcd`` matches the value ``xyzabcdpqr``, but not for ``xyzbcdpqr``."
                },
                "string_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "If specified, header match will be performed based on the string match of the header value."
                },
                "invert_match": {
                    "type": "boolean",
                    "description": "If specified, the match result will be inverted before checking. Defaults to false. Examples: * The regex ``\\d{3}`` does not match the value ``1234``, so it will match when inverted. * The range [-10,0) will match the value -1, so it will not match when inverted."
                },
                "treat_missing_header_as_empty": {
                    "type": "boolean",
                    "description": "If specified, for any header match rule, if the header match rule specified header does not exist, this header value will be treated as empty. Defaults to false. Examples: * The header match rule specified header \"header1\" to range match of [0, 10],   :ref:`invert_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match\u003e`   is set to true and :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to true; The \"header1\" header is not present. The match rule will   treat the \"header1\" as an empty header. The empty header does not match the range,   so it will match when inverted. * The header match rule specified header \"header2\" to range match of [0, 10],   :ref:`invert_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match\u003e`   is set to true and :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to false; The \"header2\" header is not present and the header   matcher rule for \"header2\" will be ignored so it will not match. * The header match rule specified header \"header3\" to a string regex match   ``^$`` which means an empty string, and   :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to true; The \"header3\" header is not present.   The match rule will treat the \"header3\" header as an empty header so it will match. * The header match rule specified header \"header4\" to a string regex match   ``^$`` which means an empty string, and   :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to false; The \"header4\" header is not present.   The match rule for \"header4\" will be ignored so it will not match."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Matcher",
            "description": ".. attention::   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1 ``Host``   header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead. .. attention::   To route on HTTP method, use the special HTTP/2 ``:method`` header. This works for both   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,   .. code-block:: json     {       \"name\": \":method\",       \"string_match\": {         \"exact\": \"POST\"       }     } .. attention::   In the absence of any header match specifier, match will default to :ref:`present_match   \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.present_match\u003e`. i.e, a request that has the :ref:`name   \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.name\u003e` header will match, regardless of the header's   value.  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.] [#next-free-field: 15]"
        },
        "envoy.config.route.v3.HedgePolicy": {
            "properties": {
                "initial_requests": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specifies the number of initial requests that should be sent upstream. Must be at least 1. Defaults to 1. [#not-implemented-hide:]"
                },
                "additional_request_chance": {
                    "$ref": "#/definitions/envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "Specifies a probability that an additional upstream request should be sent on top of what is specified by initial_requests. Defaults to 0. [#not-implemented-hide:]"
                },
                "hedge_on_per_try_timeout": {
                    "type": "boolean",
                    "description": "Indicates that a hedged request should be sent when the per-try timeout is hit. This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight. The first request to complete successfully will be the one returned to the caller. * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client. * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client   if there are no more retries left. * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress. Note: For this to have effect, you must have a :ref:`RetryPolicy \u003cenvoy_v3_api_msg_config.route.v3.RetryPolicy\u003e` that retries at least one error code and specifies a maximum number of retries. Defaults to false."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Hedge Policy",
            "description": "HTTP request hedging :ref:`architecture overview \u003carch_overview_http_routing_hedging\u003e`."
        },
        "envoy.config.route.v3.InternalRedirectPolicy": {
            "properties": {
                "max_internal_redirects": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "An internal redirect is not handled, unless the number of previous internal redirects that a downstream request has encountered is lower than this value. In the case where a downstream request is bounced among multiple routes by internal redirect, the first route that hits this threshold, or does not set :ref:`internal_redirect_policy \u003cenvoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_policy\u003e` will pass the redirect back to downstream. If not specified, at most one redirect will be followed."
                },
                "redirect_response_codes": {
                    "items": {
                        "type": "integer"
                    },
                    "maxItems": 5,
                    "type": "array",
                    "description": "Defines what upstream response codes are allowed to trigger internal redirect. If unspecified, only 302 will be treated as internal redirect. Only 301, 302, 303, 307 and 308 are valid values. Any other codes will be ignored."
                },
                "predicates": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig"
                    },
                    "type": "array",
                    "description": "Specifies a list of predicates that are queried when an upstream response is deemed to trigger an internal redirect by all other criteria. Any predicate in the list can reject the redirect, causing the response to be proxied to downstream. [#extension-category: envoy.internal_redirect_predicates]"
                },
                "allow_cross_scheme_redirect": {
                    "type": "boolean",
                    "description": "Allow internal redirect to follow a target URI with a different scheme than the value of x-forwarded-proto. The default is false."
                },
                "response_headers_to_copy": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Specifies a list of headers, by name, to copy from the internal redirect into the subsequent request. If a header is specified here but not present in the redirect, it will be cleared in the subsequent request."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Internal Redirect Policy",
            "description": "HTTP Internal Redirect :ref:`architecture overview \u003carch_overview_internal_redirects\u003e`. [#next-free-field: 6]"
        },
        "envoy.config.route.v3.NonForwardingAction": {
            "additionalProperties": true,
            "type": "object",
            "title": "Non Forwarding Action",
            "description": "[#not-implemented-hide:]"
        },
        "envoy.config.route.v3.QueryParameterMatcher": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Specifies the name of a key that must be present in the requested ``path``'s query string."
                },
                "string_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "Specifies whether a query parameter value should match against a string."
                },
                "present_match": {
                    "type": "boolean",
                    "description": "Specifies whether a query parameter should be present."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Query Parameter Matcher",
            "description": "Query parameter matching treats the query string of a request's :path header as an ampersand-separated list of keys and/or key=value elements. [#next-free-field: 7]"
        },
        "envoy.config.route.v3.RateLimit": {
            "properties": {
                "stage": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Refers to the stage set in the filter. The rate limit configuration only applies to filters with the same stage number. The default stage number is 0. .. note::   The filter supports a range of 0 - 10 inclusively for stage numbers."
                },
                "disable_key": {
                    "type": "string",
                    "description": "The key to be set in runtime to disable this rate limit configuration."
                },
                "actions": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action"
                    },
                    "type": "array",
                    "description": "A list of actions that are to be applied for this rate limit configuration. Order matters as the actions are processed sequentially and the descriptor is composed by appending descriptor entries in that sequence. If an action cannot append a descriptor entry, no descriptor is generated for the configuration. See :ref:`composing actions \u003cconfig_http_filters_rate_limit_composing_actions\u003e` for additional documentation."
                },
                "limit": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Override",
                    "additionalProperties": true,
                    "description": "An optional limit override to be appended to the descriptor produced by this rate limit configuration. If the override value is invalid or cannot be resolved from metadata, no override is provided. See :ref:`rate limit override \u003cconfig_http_filters_rate_limit_rate_limit_override\u003e` for more information."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Rate Limit",
            "description": "Global rate limiting :ref:`architecture overview \u003carch_overview_global_rate_limit\u003e`. Also applies to Local rate limiting :ref:`using descriptors \u003cconfig_http_filters_local_rate_limit_descriptors\u003e`."
        },
        "envoy.config.route.v3.RateLimit.Action": {
            "properties": {
                "source_cluster": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.SourceCluster",
                    "additionalProperties": true,
                    "description": "Rate limit on source cluster."
                },
                "destination_cluster": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.DestinationCluster",
                    "additionalProperties": true,
                    "description": "Rate limit on destination cluster."
                },
                "request_headers": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.RequestHeaders",
                    "additionalProperties": true,
                    "description": "Rate limit on request headers."
                },
                "remote_address": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.RemoteAddress",
                    "additionalProperties": true,
                    "description": "Rate limit on remote address."
                },
                "generic_key": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.GenericKey",
                    "additionalProperties": true,
                    "description": "Rate limit on a generic key."
                },
                "header_value_match": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.HeaderValueMatch",
                    "additionalProperties": true,
                    "description": "Rate limit on the existence of request headers."
                },
                "dynamic_metadata": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.DynamicMetaData",
                    "additionalProperties": true,
                    "description": "Rate limit on dynamic metadata. .. attention::   This field has been deprecated in favor of the :ref:`metadata \u003cenvoy_v3_api_field_config.route.v3.RateLimit.Action.metadata\u003e` field"
                },
                "metadata": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.MetaData",
                    "additionalProperties": true,
                    "description": "Rate limit on metadata."
                },
                "extension": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Rate limit descriptor extension. See the rate limit descriptor extensions documentation. :ref:`HTTP matching input functions \u003carch_overview_matching_api\u003e` are permitted as descriptor extensions. The input functions are only looked up if there is no rate limit descriptor extension matching the type URL. [#extension-category: envoy.rate_limit_descriptors]"
                },
                "masked_remote_address": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress",
                    "additionalProperties": true,
                    "description": "Rate limit on masked remote address."
                },
                "query_parameter_value_match": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch",
                    "additionalProperties": true,
                    "description": "Rate limit on the existence of query parameters."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Action",
            "description": "[#next-free-field: 12]"
        },
        "envoy.config.route.v3.RateLimit.Action.DestinationCluster": {
            "additionalProperties": true,
            "type": "object",
            "title": "Destination Cluster",
            "description": "The following descriptor entry is appended to the descriptor: .. code-block:: cpp   (\"destination_cluster\", \"\u003crouted target cluster\u003e\") Once a request matches against a route table rule, a routed cluster is determined by one of the following :ref:`route table configuration \u003cenvoy_v3_api_msg_config.route.v3.RouteConfiguration\u003e` settings: * :ref:`cluster \u003cenvoy_v3_api_field_config.route.v3.RouteAction.cluster\u003e` indicates the upstream cluster   to route to. * :ref:`weighted_clusters \u003cenvoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters\u003e`   chooses a cluster randomly from a set of clusters with attributed weight. * :ref:`cluster_header \u003cenvoy_v3_api_field_config.route.v3.RouteAction.cluster_header\u003e` indicates which   header in the request contains the target cluster."
        },
        "envoy.config.route.v3.RateLimit.Action.DynamicMetaData": {
            "properties": {
                "descriptor_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The key to use in the descriptor entry."
                },
                "metadata_key": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKey",
                    "additionalProperties": true,
                    "description": "Metadata struct that defines the key and path to retrieve the string value. A match will only happen if the value in the dynamic metadata is of type string."
                },
                "default_value": {
                    "type": "string",
                    "description": "An optional value to use if ``metadata_key`` is empty. If not set and no value is present under the metadata_key then no descriptor is generated."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Dynamic Meta Data",
            "description": "The following descriptor entry is appended when the :ref:`dynamic metadata \u003cwell_known_dynamic_metadata\u003e` contains a key value: .. code-block:: cpp   (\"\u003cdescriptor_key\u003e\", \"\u003cvalue_queried_from_dynamic_metadata\u003e\") .. attention::   This action has been deprecated in favor of the :ref:`metadata \u003cenvoy_v3_api_msg_config.route.v3.RateLimit.Action.MetaData\u003e` action"
        },
        "envoy.config.route.v3.RateLimit.Action.GenericKey": {
            "properties": {
                "descriptor_value": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The value to use in the descriptor entry."
                },
                "descriptor_key": {
                    "type": "string",
                    "description": "An optional key to use in the descriptor entry. If not set it defaults to 'generic_key' as the descriptor key."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Generic Key",
            "description": "The following descriptor entry is appended to the descriptor: .. code-block:: cpp   (\"generic_key\", \"\u003cdescriptor_value\u003e\")"
        },
        "envoy.config.route.v3.RateLimit.Action.HeaderValueMatch": {
            "properties": {
                "descriptor_key": {
                    "type": "string",
                    "description": "The key to use in the descriptor entry. Defaults to ``header_match``."
                },
                "descriptor_value": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The value to use in the descriptor entry."
                },
                "expect_match": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "If set to true, the action will append a descriptor entry when the request matches the headers. If set to false, the action will append a descriptor entry when the request does not match the headers. The default value is true."
                },
                "headers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.HeaderMatcher"
                    },
                    "type": "array",
                    "description": "Specifies a set of headers that the rate limit action should match on. The action will check the request’s headers against all the specified headers in the config. A match will happen if all the headers in the config are present in the request with the same values (or based on presence if the value field is not in the config)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Value Match",
            "description": "The following descriptor entry is appended to the descriptor: .. code-block:: cpp   (\"header_match\", \"\u003cdescriptor_value\u003e\")"
        },
        "envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress": {
            "properties": {
                "v4_prefix_mask_len": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Length of prefix mask len for IPv4 (e.g. 0, 32). Defaults to 32 when unset. For example, trusted address from x-forwarded-for is ``192.168.1.1``, the descriptor entry is (\"masked_remote_address\", \"192.168.1.1/32\"); if mask len is 24, the descriptor entry is (\"masked_remote_address\", \"192.168.1.0/24\")."
                },
                "v6_prefix_mask_len": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Length of prefix mask len for IPv6 (e.g. 0, 128). Defaults to 128 when unset. For example, trusted address from x-forwarded-for is ``2001:abcd:ef01:2345:6789:abcd:ef01:234``, the descriptor entry is (\"masked_remote_address\", \"2001:abcd:ef01:2345:6789:abcd:ef01:234/128\"); if mask len is 64, the descriptor entry is (\"masked_remote_address\", \"2001:abcd:ef01:2345::/64\")."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Masked Remote Address",
            "description": "The following descriptor entry is appended to the descriptor and is populated using the masked address from :ref:`x-forwarded-for \u003cconfig_http_conn_man_headers_x-forwarded-for\u003e`: .. code-block:: cpp   (\"masked_remote_address\", \"\u003cmasked address from x-forwarded-for\u003e\")"
        },
        "envoy.config.route.v3.RateLimit.Action.MetaData": {
            "properties": {
                "descriptor_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The key to use in the descriptor entry."
                },
                "metadata_key": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKey",
                    "additionalProperties": true,
                    "description": "Metadata struct that defines the key and path to retrieve the string value. A match will only happen if the value in the metadata is of type string."
                },
                "default_value": {
                    "type": "string",
                    "description": "An optional value to use if ``metadata_key`` is empty. If not set and no value is present under the metadata_key then ``skip_if_absent`` is followed to skip calling the rate limiting service or skip the descriptor."
                },
                "source": {
                    "enum": [
                        "DYNAMIC",
                        0,
                        "ROUTE_ENTRY",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Source"
                },
                "skip_if_absent": {
                    "type": "boolean",
                    "description": "If set to true, Envoy skips the descriptor while calling rate limiting service when ``metadata_key`` is empty and ``default_value`` is not set. By default it skips calling the rate limiting service in that case."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Meta Data",
            "description": "The following descriptor entry is appended when the metadata contains a key value: .. code-block:: cpp   (\"\u003cdescriptor_key\u003e\", \"\u003cvalue_queried_from_metadata\u003e\") [#next-free-field: 6]"
        },
        "envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch": {
            "properties": {
                "descriptor_key": {
                    "type": "string",
                    "description": "The key to use in the descriptor entry. Defaults to ``query_match``."
                },
                "descriptor_value": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The value to use in the descriptor entry."
                },
                "expect_match": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "If set to true, the action will append a descriptor entry when the request matches the headers. If set to false, the action will append a descriptor entry when the request does not match the headers. The default value is true."
                },
                "query_parameters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.QueryParameterMatcher"
                    },
                    "type": "array",
                    "description": "Specifies a set of query parameters that the rate limit action should match on. The action will check the request’s query parameters against all the specified query parameters in the config. A match will happen if all the query parameters in the config are present in the request with the same values (or based on presence if the value field is not in the config)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Query Parameter Value Match",
            "description": "The following descriptor entry is appended to the descriptor: .. code-block:: cpp   (\"query_match\", \"\u003cdescriptor_value\u003e\")"
        },
        "envoy.config.route.v3.RateLimit.Action.RemoteAddress": {
            "additionalProperties": true,
            "type": "object",
            "title": "Remote Address",
            "description": "The following descriptor entry is appended to the descriptor and is populated using the trusted address from :ref:`x-forwarded-for \u003cconfig_http_conn_man_headers_x-forwarded-for\u003e`: .. code-block:: cpp   (\"remote_address\", \"\u003ctrusted address from x-forwarded-for\u003e\")"
        },
        "envoy.config.route.v3.RateLimit.Action.RequestHeaders": {
            "properties": {
                "header_name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The header name to be queried from the request headers. The header’s value is used to populate the value of the descriptor entry for the descriptor_key."
                },
                "descriptor_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The key to use in the descriptor entry."
                },
                "skip_if_absent": {
                    "type": "boolean",
                    "description": "If set to true, Envoy skips the descriptor while calling rate limiting service when header is not present in the request. By default it skips calling the rate limiting service if this header is not present in the request."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Request Headers",
            "description": "The following descriptor entry is appended when a header contains a key that matches the ``header_name``: .. code-block:: cpp   (\"\u003cdescriptor_key\u003e\", \"\u003cheader_value_queried_from_header\u003e\")"
        },
        "envoy.config.route.v3.RateLimit.Action.SourceCluster": {
            "additionalProperties": true,
            "type": "object",
            "title": "Source Cluster",
            "description": "The following descriptor entry is appended to the descriptor: .. code-block:: cpp   (\"source_cluster\", \"\u003clocal service cluster\u003e\") \u003clocal service cluster\u003e is derived from the :option:`--service-cluster` option."
        },
        "envoy.config.route.v3.RateLimit.Override": {
            "properties": {
                "dynamic_metadata": {
                    "$ref": "#/definitions/envoy.config.route.v3.RateLimit.Override.DynamicMetadata",
                    "additionalProperties": true,
                    "description": "Limit override from dynamic metadata."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Override"
        },
        "envoy.config.route.v3.RateLimit.Override.DynamicMetadata": {
            "properties": {
                "metadata_key": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKey",
                    "additionalProperties": true,
                    "description": "Metadata struct that defines the key and path to retrieve the struct value. The value must be a struct containing an integer \"requests_per_unit\" property and a \"unit\" property with a value parseable to :ref:`RateLimitUnit enum \u003cenvoy_v3_api_enum_type.v3.RateLimitUnit\u003e`"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Dynamic Metadata",
            "description": "Fetches the override from the dynamic metadata."
        },
        "envoy.config.route.v3.RedirectAction": {
            "properties": {
                "https_redirect": {
                    "type": "boolean",
                    "description": "The scheme portion of the URL will be swapped with \"https\"."
                },
                "scheme_redirect": {
                    "type": "string",
                    "description": "The scheme portion of the URL will be swapped with this value."
                },
                "host_redirect": {
                    "type": "string",
                    "description": "The host portion of the URL will be swapped with this value."
                },
                "port_redirect": {
                    "type": "integer",
                    "description": "The port value of the URL will be swapped with this value."
                },
                "path_redirect": {
                    "type": "string",
                    "description": "The path portion of the URL will be swapped with this value. Please note that query string in path_redirect will override the request's query string and will not be stripped. For example, let's say we have the following routes: - match: { path: \"/old-path-1\" }   redirect: { path_redirect: \"/new-path-1\" } - match: { path: \"/old-path-2\" }   redirect: { path_redirect: \"/new-path-2\", strip-query: \"true\" } - match: { path: \"/old-path-3\" }   redirect: { path_redirect: \"/new-path-3?foo=1\", strip_query: \"true\" } 1. if request uri is \"/old-path-1?bar=1\", users will be redirected to \"/new-path-1?bar=1\" 2. if request uri is \"/old-path-2?bar=1\", users will be redirected to \"/new-path-2\" 3. if request uri is \"/old-path-3?bar=1\", users will be redirected to \"/new-path-3?foo=1\""
                },
                "prefix_rewrite": {
                    "type": "string",
                    "description": "Indicates that during redirection, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request. .. attention::   Pay attention to the use of trailing slashes as mentioned in   :ref:`RouteAction's prefix_rewrite \u003cenvoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite\u003e`."
                },
                "regex_rewrite": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatchAndSubstitute",
                    "additionalProperties": true,
                    "description": "Indicates that during redirect, portions of the path that match the pattern should be rewritten, even allowing the substitution of capture groups from the pattern into the new path as specified by the rewrite substitution string. This is useful to allow application paths to be rewritten in a way that is aware of segments with variable content like identifiers. Examples using Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ engine: * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution   string of ``\\2/instance/\\1`` would transform ``/service/foo/v1/api``   into ``/v1/api/instance/foo``. * The pattern ``one`` paired with a substitution string of ``two`` would   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``. * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of   ``\\1two\\2`` would replace only the first occurrence of ``one``,   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``. * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to   ``/aaa/yyy/bbb``."
                },
                "response_code": {
                    "enum": [
                        "MOVED_PERMANENTLY",
                        0,
                        "FOUND",
                        1,
                        "SEE_OTHER",
                        2,
                        "TEMPORARY_REDIRECT",
                        3,
                        "PERMANENT_REDIRECT",
                        4
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Redirect Response Code"
                },
                "strip_query": {
                    "type": "boolean",
                    "description": "Indicates that during redirection, the query portion of the URL will be removed. Default value is false."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Redirect Action",
            "description": "[#next-free-field: 10]"
        },
        "envoy.config.route.v3.RetryPolicy": {
            "properties": {
                "retry_on": {
                    "type": "string",
                    "description": "Specifies the conditions under which retry takes place. These are the same conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and :ref:`config_http_filters_router_x-envoy-retry-grpc-on`."
                },
                "num_retries": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specifies the allowed number of retries. This parameter is optional and defaults to 1. These are the same conditions documented for :ref:`config_http_filters_router_x-envoy-max-retries`."
                },
                "per_try_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies a non-zero upstream timeout per retry attempt (including the initial attempt). This parameter is optional. The same conditions documented for :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply. .. note::   If left unspecified, Envoy will use the global   :ref:`route timeout \u003cenvoy_v3_api_field_config.route.v3.RouteAction.timeout\u003e` for the request.   Consequently, when using a :ref:`5xx \u003cconfig_http_filters_router_x-envoy-retry-on\u003e` based   retry policy, a request that times out will not be retried as the total timeout budget   would have been exhausted.",
                    "format": "regex"
                },
                "per_try_idle_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies an upstream idle timeout per retry attempt (including the initial attempt). This parameter is optional and if absent there is no per try idle timeout. The semantics of the per try idle timeout are similar to the :ref:`route idle timeout \u003cenvoy_v3_api_field_config.route.v3.RouteAction.timeout\u003e` and :ref:`stream idle timeout \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout\u003e` both enforced by the HTTP connection manager. The difference is that this idle timeout is enforced by the router for each individual attempt and thus after all previous filters have run, as opposed to *before* all previous filters run for the other idle timeouts. This timeout is useful in cases in which total request timeout is bounded by a number of retries and a :ref:`per_try_timeout \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout\u003e`, but there is a desire to ensure each try is making incremental progress. Note also that similar to :ref:`per_try_timeout \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout\u003e`, this idle timeout does not start until after both the entire request has been received by the router *and* a connection pool connection has been obtained. Unlike :ref:`per_try_timeout \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout\u003e`, the idle timer continues once the response starts streaming back to the downstream client. This ensures that response data continues to make progress without using one of the HTTP connection manager idle timeouts.",
                    "format": "regex"
                },
                "retry_priority": {
                    "$ref": "#/definitions/envoy.config.route.v3.RetryPolicy.RetryPriority",
                    "additionalProperties": true,
                    "description": "Specifies an implementation of a RetryPriority which is used to determine the distribution of load across priorities used for retries. Refer to :ref:`retry plugin configuration \u003carch_overview_http_retry_plugins\u003e` for more details."
                },
                "retry_host_predicate": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.RetryPolicy.RetryHostPredicate"
                    },
                    "type": "array",
                    "description": "Specifies a collection of RetryHostPredicates that will be consulted when selecting a host for retries. If any of the predicates reject the host, host selection will be reattempted. Refer to :ref:`retry plugin configuration \u003carch_overview_http_retry_plugins\u003e` for more details."
                },
                "retry_options_predicates": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig"
                    },
                    "type": "array",
                    "description": "Retry options predicates that will be applied prior to retrying a request. These predicates allow customizing request behavior between retries. [#comment: add [#extension-category: envoy.retry_options_predicates] when there are built-in extensions]"
                },
                "host_selection_retry_max_attempts": {
                    "type": "string",
                    "description": "The maximum number of times host selection will be reattempted before giving up, at which point the host that was last selected will be routed to. If unspecified, this will default to retrying once."
                },
                "retriable_status_codes": {
                    "items": {
                        "type": "integer"
                    },
                    "type": "array",
                    "description": "HTTP status codes that should trigger a retry in addition to those specified by retry_on."
                },
                "retry_back_off": {
                    "$ref": "#/definitions/envoy.config.route.v3.RetryPolicy.RetryBackOff",
                    "additionalProperties": true,
                    "description": "Specifies parameters that control exponential retry back off. This parameter is optional, in which case the default base interval is 25 milliseconds or, if set, the current value of the ``upstream.base_retry_backoff_ms`` runtime parameter. The default maximum interval is 10 times the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries` describes Envoy's back-off algorithm."
                },
                "rate_limited_retry_back_off": {
                    "$ref": "#/definitions/envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff",
                    "additionalProperties": true,
                    "description": "Specifies parameters that control a retry back-off strategy that is used when the request is rate limited by the upstream server. The server may return a response header like ``Retry-After`` or ``X-RateLimit-Reset`` to provide feedback to the client on how long to wait before retrying. If configured, this back-off strategy will be used instead of the default exponential back off strategy (configured using ``retry_back_off``) whenever a response includes the matching headers."
                },
                "retriable_headers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.HeaderMatcher"
                    },
                    "type": "array",
                    "description": "HTTP response headers that trigger a retry if present in the response. A retry will be triggered if any of the header matches match the upstream response headers. The field is only consulted if 'retriable-headers' retry policy is active."
                },
                "retriable_request_headers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.HeaderMatcher"
                    },
                    "type": "array",
                    "description": "HTTP headers which must be present in the request for retries to be attempted."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Policy",
            "description": "HTTP retry :ref:`architecture overview \u003carch_overview_http_routing_retry\u003e`. [#next-free-field: 14]"
        },
        "envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff": {
            "properties": {
                "reset_headers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.RetryPolicy.ResetHeader"
                    },
                    "type": "array",
                    "description": "Specifies the reset headers (like ``Retry-After`` or ``X-RateLimit-Reset``) to match against the response. Headers are tried in order, and matched case insensitive. The first header to be parsed successfully is used. If no headers match the default exponential back-off is used instead."
                },
                "max_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the maximum back off interval that Envoy will allow. If a reset header contains an interval longer than this then it will be discarded and the next header will be tried. Defaults to 300 seconds.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Rate Limited Retry Back Off",
            "description": "A retry back-off strategy that applies when the upstream server rate limits the request. Given this configuration: .. code-block:: yaml   rate_limited_retry_back_off:     reset_headers:     - name: Retry-After       format: SECONDS     - name: X-RateLimit-Reset       format: UNIX_TIMESTAMP     max_interval: \"300s\" The following algorithm will apply:  1. If the response contains the header ``Retry-After`` its value must be on     the form ``120`` (an integer that represents the number of seconds to     wait before retrying). If so, this value is used as the back-off interval.  2. Otherwise, if the response contains the header ``X-RateLimit-Reset`` its     value must be on the form ``1595320702`` (an integer that represents the     point in time at which to retry, as a Unix timestamp in seconds). If so,     the current time is subtracted from this value and the result is used as     the back-off interval.  3. Otherwise, Envoy will use the default     :ref:`exponential back-off \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_back_off\u003e`     strategy. No matter which format is used, if the resulting back-off interval exceeds ``max_interval`` it is discarded and the next header in ``reset_headers`` is tried. If a request timeout is configured for the route it will further limit how long the request will be allowed to run. To prevent many clients retrying at the same point in time jitter is added to the back-off interval, so the resulting interval is decided by taking: ``random(interval, interval * 1.5)``. .. attention::   Configuring ``rate_limited_retry_back_off`` will not by itself cause a request   to be retried. You will still need to configure the right retry policy to match   the responses from the upstream server."
        },
        "envoy.config.route.v3.RetryPolicy.ResetHeader": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the reset header. .. note::   If the header appears multiple times only the first value is used."
                },
                "format": {
                    "enum": [
                        "SECONDS",
                        0,
                        "UNIX_TIMESTAMP",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Reset Header Format"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Reset Header"
        },
        "envoy.config.route.v3.RetryPolicy.RetryBackOff": {
            "properties": {
                "base_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the base interval between retries. This parameter is required and must be greater than zero. Values less than 1 ms are rounded up to 1 ms. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's back-off algorithm.",
                    "format": "regex"
                },
                "max_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the maximum interval between retries. This parameter is optional, but must be greater than or equal to the ``base_interval`` if set. The default is 10 times the ``base_interval``. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's back-off algorithm.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Back Off"
        },
        "envoy.config.route.v3.RetryPolicy.RetryHostPredicate": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string"
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Host Predicate"
        },
        "envoy.config.route.v3.RetryPolicy.RetryPriority": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string"
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Priority"
        },
        "envoy.config.route.v3.RouteAction": {
            "properties": {
                "cluster": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Indicates the upstream cluster to which the request should be routed to."
                },
                "cluster_header": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Envoy will determine the cluster to route to by reading the value of the HTTP header named by cluster_header from the request headers. If the header is not found or the referenced cluster does not exist, Envoy will return a 404 response. .. attention::   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead. .. note::   If the header appears multiple times only the first value is used."
                },
                "weighted_clusters": {
                    "$ref": "#/definitions/envoy.config.route.v3.WeightedCluster",
                    "additionalProperties": true,
                    "description": "Multiple upstream clusters can be specified for a given route. The request is routed to one of the upstream clusters based on weights assigned to each cluster. See :ref:`traffic splitting \u003cconfig_http_conn_man_route_table_traffic_splitting_split\u003e` for additional documentation."
                },
                "cluster_specifier_plugin": {
                    "type": "string",
                    "description": "Name of the cluster specifier plugin to use to determine the cluster for requests on this route. The cluster specifier plugin name must be defined in the associated :ref:`cluster specifier plugins \u003cenvoy_v3_api_field_config.route.v3.RouteConfiguration.cluster_specifier_plugins\u003e` in the :ref:`name \u003cenvoy_v3_api_field_config.core.v3.TypedExtensionConfig.name\u003e` field."
                },
                "inline_cluster_specifier_plugin": {
                    "$ref": "#/definitions/envoy.config.route.v3.ClusterSpecifierPlugin",
                    "additionalProperties": true,
                    "description": "Custom cluster specifier plugin configuration to use to determine the cluster for requests on this route."
                },
                "cluster_not_found_response_code": {
                    "enum": [
                        "SERVICE_UNAVAILABLE",
                        0,
                        "NOT_FOUND",
                        1,
                        "INTERNAL_SERVER_ERROR",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Cluster Not Found Response Code"
                },
                "metadata_match": {
                    "$ref": "#/definitions/envoy.config.core.v3.Metadata",
                    "additionalProperties": true,
                    "description": "Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in the upstream cluster with metadata matching what's set in this field will be considered for load balancing. If using :ref:`weighted_clusters \u003cenvoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters\u003e`, metadata will be merged, with values provided there taking precedence. The filter name should be specified as ``envoy.lb``."
                },
                "prefix_rewrite": {
                    "type": "string",
                    "description": "Indicates that during forwarding, the matched prefix (or path) should be swapped with this value. This option allows application URLs to be rooted at a different path from those exposed at the reverse proxy layer. The router filter will place the original path before rewrite into the :ref:`x-envoy-original-path \u003cconfig_http_filters_router_x-envoy-original-path\u003e` header. Only one of :ref:`regex_rewrite \u003cenvoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite\u003e` :ref:`path_rewrite_policy \u003cenvoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy\u003e`, or :ref:`prefix_rewrite \u003cenvoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite\u003e` may be specified. .. attention::   Pay careful attention to the use of trailing slashes in the   :ref:`route's match \u003cenvoy_v3_api_field_config.route.v3.Route.match\u003e` prefix value.   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,   rewriting ``/prefix`` to ``/`` and ``/prefix/etc`` to ``/etc`` cannot be done in a single   :ref:`Route \u003cenvoy_v3_api_msg_config.route.v3.Route\u003e`, as shown by the below config entries:   .. code-block:: yaml     - match:         prefix: \"/prefix/\"       route:         prefix_rewrite: \"/\"     - match:         prefix: \"/prefix\"       route:         prefix_rewrite: \"/\"   Having above entries in the config, requests to ``/prefix`` will be stripped to ``/``, while   requests to ``/prefix/etc`` will be stripped to ``/etc``."
                },
                "regex_rewrite": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatchAndSubstitute",
                    "additionalProperties": true,
                    "description": "Indicates that during forwarding, portions of the path that match the pattern should be rewritten, even allowing the substitution of capture groups from the pattern into the new path as specified by the rewrite substitution string. This is useful to allow application paths to be rewritten in a way that is aware of segments with variable content like identifiers. The router filter will place the original path as it was before the rewrite into the :ref:`x-envoy-original-path \u003cconfig_http_filters_router_x-envoy-original-path\u003e` header. Only one of :ref:`regex_rewrite \u003cenvoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite\u003e`, :ref:`prefix_rewrite \u003cenvoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite\u003e`, or :ref:`path_rewrite_policy \u003cenvoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy\u003e`] may be specified. Examples using Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ engine: * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution   string of ``\\2/instance/\\1`` would transform ``/service/foo/v1/api``   into ``/v1/api/instance/foo``. * The pattern ``one`` paired with a substitution string of ``two`` would   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``. * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of   ``\\1two\\2`` would replace only the first occurrence of ``one``,   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``. * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to   ``/aaa/yyy/bbb``."
                },
                "path_rewrite_policy": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "[#extension-category: envoy.path.rewrite]"
                },
                "host_rewrite_literal": {
                    "type": "string",
                    "description": "Indicates that during forwarding, the host header will be swapped with this value. Using this option will append the :ref:`config_http_conn_man_headers_x-forwarded-host` header if :ref:`append_x_forwarded_host \u003cenvoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host\u003e` is set."
                },
                "auto_host_rewrite": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Indicates that during forwarding, the host header will be swapped with the hostname of the upstream host chosen by the cluster manager. This option is applicable only when the destination cluster for a route is of type ``strict_dns`` or ``logical_dns``, or when :ref:`hostname \u003cenvoy_v3_api_field_config.endpoint.v3.Endpoint.hostname\u003e` field is not empty. Setting this to true with other cluster types has no effect. Using this option will append the :ref:`config_http_conn_man_headers_x-forwarded-host` header if :ref:`append_x_forwarded_host \u003cenvoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host\u003e` is set."
                },
                "host_rewrite_header": {
                    "type": "string",
                    "description": "Indicates that during forwarding, the host header will be swapped with the content of given downstream or :ref:`custom \u003cconfig_http_conn_man_headers_custom_request_headers\u003e` header. If header value is empty, host header is left intact. Using this option will append the :ref:`config_http_conn_man_headers_x-forwarded-host` header if :ref:`append_x_forwarded_host \u003cenvoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host\u003e` is set. .. attention::   Pay attention to the potential security implications of using this option. Provided header   must come from trusted source. .. note::   If the header appears multiple times only the first value is used."
                },
                "host_rewrite_path_regex": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatchAndSubstitute",
                    "additionalProperties": true,
                    "description": "Indicates that during forwarding, the host header will be swapped with the result of the regex substitution executed on path value with query and fragment removed. This is useful for transitioning variable content between path segment and subdomain. Using this option will append the :ref:`config_http_conn_man_headers_x-forwarded-host` header if :ref:`append_x_forwarded_host \u003cenvoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host\u003e` is set. For example with the following config:   .. code-block:: yaml     host_rewrite_path_regex:       pattern:         google_re2: {}         regex: \"^/(.+)/.+$\"       substitution: \\1 Would rewrite the host header to ``envoyproxy.io`` given the path ``/envoyproxy.io/some/path``."
                },
                "append_x_forwarded_host": {
                    "type": "boolean",
                    "description": "If set, then a host rewrite action (one of :ref:`host_rewrite_literal \u003cenvoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_literal\u003e`, :ref:`auto_host_rewrite \u003cenvoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite\u003e`, :ref:`host_rewrite_header \u003cenvoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_header\u003e`, or :ref:`host_rewrite_path_regex \u003cenvoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_path_regex\u003e`) causes the original value of the host header, if any, to be appended to the :ref:`config_http_conn_man_headers_x-forwarded-host` HTTP header if it is different to the last value appended."
                },
                "timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the upstream timeout for the route. If not specified, the default is 15s. This spans between the point at which the entire downstream request (i.e. end-of-stream) has been processed and when the upstream response has been completely processed. A value of 0 will disable the route's timeout. .. note::   This timeout includes all retries. See also   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the   :ref:`retry overview \u003carch_overview_http_routing_retry\u003e`.",
                    "format": "regex"
                },
                "idle_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout, although the connection manager wide :ref:`stream_idle_timeout \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout\u003e` will still apply. A value of 0 will completely disable the route's idle timeout, even if a connection manager stream idle timeout is configured. The idle timeout is distinct to :ref:`timeout \u003cenvoy_v3_api_field_config.route.v3.RouteAction.timeout\u003e`, which provides an upper bound on the upstream response time; :ref:`idle_timeout \u003cenvoy_v3_api_field_config.route.v3.RouteAction.idle_timeout\u003e` instead bounds the amount of time the request's stream may be idle. After header decoding, the idle timeout will apply on downstream and upstream request events. Each time an encode/decode event for headers or data is processed for the stream, the timer will be reset. If the timeout fires, the stream is terminated with a 408 Request Timeout error code if no upstream response header has been received, otherwise a stream reset occurs. If the :ref:`overload action \u003cconfig_overload_manager_overload_actions\u003e` \"envoy.overload_actions.reduce_timeouts\" is configured, this timeout is scaled according to the value for :ref:`HTTP_DOWNSTREAM_STREAM_IDLE \u003cenvoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE\u003e`.",
                    "format": "regex"
                },
                "early_data_policy": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Specifies how to send request over TLS early data. If absent, allows `safe HTTP requests \u003chttps://www.rfc-editor.org/rfc/rfc7231#section-4.2.1\u003e`_ to be sent on early data. [#extension-category: envoy.route.early_data_policy]"
                },
                "retry_policy": {
                    "$ref": "#/definitions/envoy.config.route.v3.RetryPolicy",
                    "additionalProperties": true,
                    "description": "Indicates that the route has a retry policy. Note that if this is set, it'll take precedence over the virtual host level retry policy entirely (e.g.: policies are not merged, most internal one becomes the enforced policy)."
                },
                "retry_policy_typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "[#not-implemented-hide:] Specifies the configuration for retry policy extension. Note that if this is set, it'll take precedence over the virtual host level retry policy entirely (e.g.: policies are not merged, most internal one becomes the enforced policy). :ref:`Retry policy \u003cenvoy_v3_api_field_config.route.v3.VirtualHost.retry_policy\u003e` should not be set if this field is used."
                },
                "request_mirror_policies": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.RouteAction.RequestMirrorPolicy"
                    },
                    "type": "array",
                    "description": "Specify a set of route request mirroring policies. It takes precedence over the virtual host and route config mirror policy entirely. That is, policies are not merged, the most specific non-empty one becomes the mirror policies."
                },
                "priority": {
                    "enum": [
                        "DEFAULT",
                        0,
                        "HIGH",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: Common types]",
                    "description": "[#protodoc-title: Common types]  Envoy supports :ref:`upstream priority routing \u003carch_overview_http_routing_priority\u003e` both at the route and the virtual cluster level. The current priority implementation uses different connection pool and circuit breaking settings for each priority level. This means that even for HTTP/2 requests, two physical connections will be used to an upstream host. In the future Envoy will likely support true HTTP/2 priority over a single upstream connection."
                },
                "rate_limits": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.RateLimit"
                    },
                    "type": "array",
                    "description": "Specifies a set of rate limit configurations that could be applied to the route."
                },
                "include_vh_rate_limits": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Specifies if the rate limit filter should include the virtual host rate limits. By default, if the route configured rate limits, the virtual host :ref:`rate_limits \u003cenvoy_v3_api_field_config.route.v3.VirtualHost.rate_limits\u003e` are not applied to the request. This field is deprecated. Please use :ref:`vh_rate_limits \u003cenvoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits\u003e`"
                },
                "hash_policy": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.RouteAction.HashPolicy"
                    },
                    "type": "array",
                    "description": "Specifies a list of hash policies to use for ring hash load balancing. Each hash policy is evaluated individually and the combined result is used to route the request. The method of combination is deterministic such that identical lists of hash policies will produce the same hash. Since a hash policy examines specific parts of a request, it can fail to produce a hash (i.e. if the hashed header is not present). If (and only if) all configured hash policies fail to generate a hash, no hash will be produced for the route. In this case, the behavior is the same as if no hash policies were specified (i.e. the ring hash load balancer will choose a random backend). If a hash policy has the \"terminal\" attribute set to true, and there is already a hash generated, the hash is returned immediately, ignoring the rest of the hash policy list."
                },
                "cors": {
                    "$ref": "#/definitions/envoy.config.route.v3.CorsPolicy",
                    "additionalProperties": true,
                    "description": "Indicates that the route has a CORS policy. This field is ignored if related cors policy is found in the :ref:`Route.typed_per_filter_config\u003cenvoy_v3_api_field_config.route.v3.Route.typed_per_filter_config\u003e` or :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config\u003cenvoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config\u003e`. .. attention::   This option has been deprecated. Please use   :ref:`Route.typed_per_filter_config\u003cenvoy_v3_api_field_config.route.v3.Route.typed_per_filter_config\u003e` or   :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config\u003cenvoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config\u003e`   to configure the CORS HTTP filter."
                },
                "max_grpc_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Deprecated by :ref:`grpc_timeout_header_max \u003cenvoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max\u003e` If present, and the request is a gRPC request, use the `grpc-timeout header \u003chttps://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\u003e`_, or its default value (infinity) instead of :ref:`timeout \u003cenvoy_v3_api_field_config.route.v3.RouteAction.timeout\u003e`, but limit the applied timeout to the maximum value specified here. If configured as 0, the maximum allowed timeout for gRPC requests is infinity. If not configured at all, the ``grpc-timeout`` header is not used and gRPC requests time out like any other requests using :ref:`timeout \u003cenvoy_v3_api_field_config.route.v3.RouteAction.timeout\u003e` or its default. This can be used to prevent unexpected upstream request timeouts due to potentially long time gaps between gRPC request and response in gRPC streaming mode. .. note::    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes    precedence over `grpc-timeout header \u003chttps://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\u003e`_, when    both are present. See also    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the    :ref:`retry overview \u003carch_overview_http_routing_retry\u003e`.",
                    "format": "regex"
                },
                "grpc_timeout_offset": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Deprecated by :ref:`grpc_timeout_header_offset \u003cenvoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset\u003e`. If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by subtracting the provided duration from the header. This is useful in allowing Envoy to set its global timeout to be less than that of the deadline imposed by the calling client, which makes it more likely that Envoy will handle the timeout instead of having the call canceled by the client. The offset will only be applied if the provided grpc_timeout is greater than the offset. This ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning infinity).",
                    "format": "regex"
                },
                "upgrade_configs": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.RouteAction.UpgradeConfig"
                    },
                    "type": "array"
                },
                "internal_redirect_policy": {
                    "$ref": "#/definitions/envoy.config.route.v3.InternalRedirectPolicy",
                    "additionalProperties": true,
                    "description": "If present, Envoy will try to follow an upstream redirect response instead of proxying the response back to the downstream. An upstream redirect response is defined by :ref:`redirect_response_codes \u003cenvoy_v3_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes\u003e`."
                },
                "internal_redirect_action": {
                    "enum": [
                        "PASS_THROUGH_INTERNAL_REDIRECT",
                        0,
                        "HANDLE_INTERNAL_REDIRECT",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Internal Redirect Action",
                    "description": "Configures :ref:`internal redirect \u003carch_overview_internal_redirects\u003e` behavior. [#next-major-version: remove this definition - it's defined in the InternalRedirectPolicy message.]"
                },
                "max_internal_redirects": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "An internal redirect is handled, iff the number of previous internal redirects that a downstream request has encountered is lower than this value, and :ref:`internal_redirect_action \u003cenvoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action\u003e` is set to :ref:`HANDLE_INTERNAL_REDIRECT \u003cenvoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT\u003e` In the case where a downstream request is bounced among multiple routes by internal redirect, the first route that hits this threshold, or has :ref:`internal_redirect_action \u003cenvoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action\u003e` set to :ref:`PASS_THROUGH_INTERNAL_REDIRECT \u003cenvoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT\u003e` will pass the redirect back to downstream. If not specified, at most one redirect will be followed."
                },
                "hedge_policy": {
                    "$ref": "#/definitions/envoy.config.route.v3.HedgePolicy",
                    "additionalProperties": true,
                    "description": "Indicates that the route has a hedge policy. Note that if this is set, it'll take precedence over the virtual host level hedge policy entirely (e.g.: policies are not merged, most internal one becomes the enforced policy)."
                },
                "max_stream_duration": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteAction.MaxStreamDuration",
                    "additionalProperties": true,
                    "description": "Specifies the maximum stream duration for this route."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Route Action",
            "description": "[#next-free-field: 42]"
        },
        "envoy.config.route.v3.RouteAction.HashPolicy": {
            "properties": {
                "header": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteAction.HashPolicy.Header",
                    "additionalProperties": true,
                    "description": "Header hash policy."
                },
                "cookie": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteAction.HashPolicy.Cookie",
                    "additionalProperties": true,
                    "description": "Cookie hash policy."
                },
                "connection_properties": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties",
                    "additionalProperties": true,
                    "description": "Connection properties hash policy."
                },
                "query_parameter": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter",
                    "additionalProperties": true,
                    "description": "Query parameter hash policy."
                },
                "filter_state": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteAction.HashPolicy.FilterState",
                    "additionalProperties": true,
                    "description": "Filter state hash policy."
                },
                "terminal": {
                    "type": "boolean",
                    "description": "The flag that short-circuits the hash computing. This field provides a 'fallback' style of configuration: \"if a terminal policy doesn't work, fallback to rest of the policy list\", it saves time when the terminal policy works. If true, and there is already a hash computed, ignore rest of the list of hash polices. For example, if the following hash methods are configured:  ========= ========  specifier terminal  ========= ========  Header A  true  Header B  false  Header C  false  ========= ======== The generateHash process ends if policy \"header A\" generates a hash, as it's a terminal policy."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Hash Policy",
            "description": "Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer \u003carch_overview_load_balancing_types\u003e`. [#next-free-field: 7]"
        },
        "envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties": {
            "properties": {
                "source_ip": {
                    "type": "boolean",
                    "description": "Hash on source IP address."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Connection Properties"
        },
        "envoy.config.route.v3.RouteAction.HashPolicy.Cookie": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the cookie that will be used to obtain the hash key. If the cookie is not present and ttl below is not set, no hash will be produced."
                },
                "ttl": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If specified, a cookie with the TTL will be generated if the cookie is not present. If the TTL is present and zero, the generated cookie will be a session cookie.",
                    "format": "regex"
                },
                "path": {
                    "type": "string",
                    "description": "The name of the path for the cookie. If no path is specified here, no path will be set for the cookie."
                },
                "attributes": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute"
                    },
                    "type": "array",
                    "description": "Additional attributes for the cookie. They will be used when generating a new cookie."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Cookie",
            "description": "Envoy supports two types of cookie affinity: 1. Passive. Envoy takes a cookie that's present in the cookies header and    hashes on its value. 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)    on the first request from the client in its response to the client,    based on the endpoint the request gets sent to. The client then    presents this on the next and all subsequent requests. The hash of    this is sufficient to ensure these requests get sent to the same    endpoint. The cookie is generated by hashing the source and    destination ports and addresses so that multiple independent HTTP2    streams on the same connection will independently receive the same    cookie, even if they arrive at the Envoy simultaneously."
        },
        "envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the cookie attribute."
                },
                "value": {
                    "type": "string",
                    "description": "The optional value of the cookie attribute."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Cookie Attribute",
            "description": "CookieAttribute defines an API for adding additional attributes for a HTTP cookie."
        },
        "envoy.config.route.v3.RouteAction.HashPolicy.FilterState": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the Object in the per-request filterState, which is an Envoy::Hashable object. If there is no data associated with the key, or the stored object is not Envoy::Hashable, no hash will be produced."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Filter State"
        },
        "envoy.config.route.v3.RouteAction.HashPolicy.Header": {
            "properties": {
                "header_name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the request header that will be used to obtain the hash key. If the request header is not present, no hash will be produced."
                },
                "regex_rewrite": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatchAndSubstitute",
                    "additionalProperties": true,
                    "description": "If specified, the request header value will be rewritten and used to produce the hash key."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header"
        },
        "envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the URL query parameter that will be used to obtain the hash key. If the parameter is not present, no hash will be produced. Query parameter names are case-sensitive. If query parameters are repeated, only the first value will be considered."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Query Parameter"
        },
        "envoy.config.route.v3.RouteAction.MaxStreamDuration": {
            "properties": {
                "max_stream_duration": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the maximum duration allowed for streams on the route. If not specified, the value from the :ref:`max_stream_duration \u003cenvoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration\u003e` field in :ref:`HttpConnectionManager.common_http_protocol_options \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.common_http_protocol_options\u003e` is used. If this field is set explicitly to zero, any HttpConnectionManager max_stream_duration timeout will be disabled for this route.",
                    "format": "regex"
                },
                "grpc_timeout_header_max": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If present, and the request contains a `grpc-timeout header \u003chttps://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\u003e`_, use that value as the ``max_stream_duration``, but limit the applied timeout to the maximum value specified here. If set to 0, the ``grpc-timeout`` header is used without modification.",
                    "format": "regex"
                },
                "grpc_timeout_header_offset": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by subtracting the provided duration from the header. This is useful for allowing Envoy to set its global timeout to be less than that of the deadline imposed by the calling client, which makes it more likely that Envoy will handle the timeout instead of having the call canceled by the client. If, after applying the offset, the resulting timeout is zero or negative, the stream will timeout immediately.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Max Stream Duration"
        },
        "envoy.config.route.v3.RouteAction.RequestMirrorPolicy": {
            "properties": {
                "cluster": {
                    "type": "string",
                    "description": "Only one of ``cluster`` and ``cluster_header`` can be specified. [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}] Specifies the cluster that requests will be mirrored to. The cluster must exist in the cluster manager configuration."
                },
                "cluster_header": {
                    "type": "string",
                    "description": "Only one of ``cluster`` and ``cluster_header`` can be specified. Envoy will determine the cluster to route to by reading the value of the HTTP header named by cluster_header from the request headers. Only the first value in header is used, and no shadow request will happen if the value is not found in headers. Envoy will not wait for the shadow cluster to respond before returning the response from the primary cluster. .. attention::   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead. .. note::   If the header appears multiple times only the first value is used."
                },
                "runtime_fraction": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeFractionalPercent",
                    "additionalProperties": true,
                    "description": "If not specified, all requests to the target cluster will be mirrored. If specified, this field takes precedence over the ``runtime_key`` field and requests must also fall under the percentage of matches indicated by this field. For some fraction N/D, a random number in the range [0,D) is selected. If the number is \u003c= the value of the numerator N, or if the key is not present, the default value, the request will be mirrored."
                },
                "trace_sampled": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Determines if the trace span should be sampled. Defaults to true."
                },
                "disable_shadow_host_suffix_append": {
                    "type": "boolean",
                    "description": "Disables appending the ``-shadow`` suffix to the shadowed ``Host`` header. Defaults to ``false``."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Request Mirror Policy",
            "description": "The router is capable of shadowing traffic from one cluster to another. The current implementation is \"fire and forget,\" meaning Envoy will not wait for the shadow cluster to respond before returning the response from the primary cluster. All normal statistics are collected for the shadow cluster making this feature useful for testing. During shadowing, the host/authority header is altered such that ``-shadow`` is appended. This is useful for logging. For example, ``cluster1`` becomes ``cluster1-shadow``. This behavior can be disabled by setting ``disable_shadow_host_suffix_append`` to ``true``. .. note::   Shadowing will not be triggered if the primary cluster does not exist. .. note::   Shadowing doesn't support Http CONNECT and upgrades. [#next-free-field: 7]"
        },
        "envoy.config.route.v3.RouteAction.UpgradeConfig": {
            "properties": {
                "upgrade_type": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The case-insensitive name of this upgrade, e.g. \"websocket\". For each upgrade type present in upgrade_configs, requests with Upgrade: [upgrade_type] will be proxied upstream."
                },
                "enabled": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Determines if upgrades are available on this route. Defaults to true."
                },
                "connect_config": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig",
                    "additionalProperties": true,
                    "description": "Configuration for sending data upstream as a raw data payload. This is used for CONNECT requests, when forwarding CONNECT payload as raw TCP. Note that CONNECT support is currently considered alpha in Envoy. [#comment: TODO(htuch): Replace the above comment with an alpha tag.]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Upgrade Config",
            "description": "Allows enabling and disabling upgrades on a per-route basis. This overrides any enabled/disabled upgrade filter chain specified in the HttpConnectionManager :ref:`upgrade_configs \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs\u003e` but does not affect any custom filter chain specified there."
        },
        "envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig": {
            "properties": {
                "proxy_protocol_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.ProxyProtocolConfig",
                    "additionalProperties": true,
                    "description": "If present, the proxy protocol header will be prepended to the CONNECT payload sent upstream."
                },
                "allow_post": {
                    "type": "boolean",
                    "description": "If set, the route will also allow forwarding POST payload as raw TCP."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Connect Config",
            "description": "Configuration for sending data upstream as a raw data payload. This is used for CONNECT or POST requests, when forwarding request payload as raw TCP."
        },
        "envoy.config.route.v3.RouteMatch": {
            "properties": {
                "prefix": {
                    "type": "string",
                    "description": "If specified, the route is a prefix rule meaning that the prefix must match the beginning of the ``:path`` header."
                },
                "path": {
                    "type": "string",
                    "description": "If specified, the route is an exact path rule meaning that the path must exactly match the ``:path`` header once the query string is removed."
                },
                "safe_regex": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "If specified, the route is a regular expression rule meaning that the regex must match the ``:path`` header once the query string is removed. The entire path (without the query string) must match the regex. The rule will not match if only a subsequence of the ``:path`` header matches the regex. [#next-major-version: In the v3 API we should redo how path specification works such that we utilize StringMatcher, and additionally have consistent options around whether we strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive to deprecate the existing options. We should even consider whether we want to do away with path_specifier entirely and just rely on a set of header matchers which can already match on :path, etc. The issue with that is it is unclear how to generically deal with query string stripping. This needs more thought.]"
                },
                "connect_matcher": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteMatch.ConnectMatcher",
                    "additionalProperties": true,
                    "description": "If this is used as the matcher, the matcher will only match CONNECT or CONNECT-UDP requests. Note that this will not match other Extended CONNECT requests (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style upgrades. This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2 and HTTP/3, where Extended CONNECT requests may have a path, the path matchers will work if there is a path present. Note that CONNECT support is currently considered alpha in Envoy. [#comment: TODO(htuch): Replace the above comment with an alpha tag.]"
                },
                "path_separated_prefix": {
                    "pattern": "^[^?#]+[^?#/]$",
                    "type": "string",
                    "description": "If specified, the route is a path-separated prefix rule meaning that the ``:path`` header (without the query string) must either exactly match the ``path_separated_prefix`` or have it as a prefix, followed by ``/`` For example, ``/api/dev`` would match ``/api/dev``, ``/api/dev/``, ``/api/dev/v1``, and ``/api/dev?param=true`` but would not match ``/api/developer`` Expect the value to not contain ``?`` or ``#`` and not to end in ``/``"
                },
                "path_match_policy": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "[#extension-category: envoy.path.match]"
                },
                "case_sensitive": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Indicates that prefix/path matching should be case sensitive. The default is true. Ignored for safe_regex matching."
                },
                "runtime_fraction": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeFractionalPercent",
                    "additionalProperties": true,
                    "description": "Indicates that the route should additionally match on a runtime key. Every time the route is considered for a match, it must also fall under the percentage of matches indicated by this field. For some fraction N/D, a random number in the range [0,D) is selected. If the number is \u003c= the value of the numerator N, or if the key is not present, the default value, the router continues to evaluate the remaining match criteria. A runtime_fraction route configuration can be used to roll out route changes in a gradual manner without full code/config deploys. Refer to the :ref:`traffic shifting \u003cconfig_http_conn_man_route_table_traffic_splitting_shift\u003e` docs for additional documentation. .. note::    Parsing this field is implemented such that the runtime key's data may be represented    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an    integer with the assumption that the value is an integral percentage out of 100. For    instance, a runtime key lookup returning the value \"42\" would parse as a FractionalPercent    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics."
                },
                "headers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.HeaderMatcher"
                    },
                    "type": "array",
                    "description": "Specifies a set of headers that the route should match on. The router will check the request’s headers against all the specified headers in the route config. A match will happen if all the headers in the route are present in the request with the same values (or based on presence if the value field is not in the config)."
                },
                "query_parameters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.QueryParameterMatcher"
                    },
                    "type": "array",
                    "description": "Specifies a set of URL query parameters on which the route should match. The router will check the query string from the ``path`` header against all the specified query parameters. If the number of specified query parameters is nonzero, they all must match the ``path`` header's query string for a match to occur. In the event query parameters are repeated, only the first value for each key will be considered. .. note::    If query parameters are used to pass request message fields when    `grpc_json_transcoder \u003chttps://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter\u003e`_    is used, the transcoded message fields maybe different. The query parameters are    url encoded, but the message fields are not. For example, if a query    parameter is \"foo%20bar\", the message field will be \"foo bar\"."
                },
                "grpc": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions",
                    "additionalProperties": true,
                    "description": "If specified, only gRPC requests will be matched. The router will check that the content-type header has a application/grpc or one of the various application/grpc+ values."
                },
                "tls_context": {
                    "$ref": "#/definitions/envoy.config.route.v3.RouteMatch.TlsContextMatchOptions",
                    "additionalProperties": true,
                    "description": "If specified, the client tls context will be matched against the defined match options. [#next-major-version: unify with RBAC]"
                },
                "dynamic_metadata": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.MetadataMatcher"
                    },
                    "type": "array",
                    "description": "Specifies a set of dynamic metadata matchers on which the route should match. The router will check the dynamic metadata against all the specified dynamic metadata matchers. If the number of specified dynamic metadata matchers is nonzero, they all must match the dynamic metadata for a match to occur."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Route Match",
            "description": "[#next-free-field: 16]"
        },
        "envoy.config.route.v3.RouteMatch.ConnectMatcher": {
            "additionalProperties": true,
            "type": "object",
            "title": "Connect Matcher",
            "description": "An extensible message for matching CONNECT or CONNECT-UDP requests."
        },
        "envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions": {
            "additionalProperties": true,
            "type": "object",
            "title": "Grpc Route Match Options"
        },
        "envoy.config.route.v3.RouteMatch.TlsContextMatchOptions": {
            "properties": {
                "presented": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "If specified, the route will match against whether or not a certificate is presented. If not specified, certificate presentation status (true or false) will not be considered when route matching."
                },
                "validated": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "If specified, the route will match against whether or not a certificate is validated. If not specified, certificate validation status (true or false) will not be considered when route matching. .. warning::    Client certificate validation is not currently performed upon TLS session resumption. For    a resumed TLS session the route will match only when ``validated`` is false, regardless of    whether the client TLS certificate is valid.    The only known workaround for this issue is to disable TLS session resumption entirely, by    setting both :ref:`disable_stateless_session_resumption \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.disable_stateless_session_resumption\u003e`    and :ref:`disable_stateful_session_resumption \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.disable_stateful_session_resumption\u003e` on the DownstreamTlsContext."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Tls Context Match Options"
        },
        "envoy.config.route.v3.Tracing": {
            "properties": {
                "client_sampling": {
                    "$ref": "#/definitions/envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "Target percentage of requests managed by this HTTP connection manager that will be force traced if the :ref:`x-client-trace-id \u003cconfig_http_conn_man_headers_x-client-trace-id\u003e` header is set. This field is a direct analog for the runtime variable 'tracing.client_enabled' in the :ref:`HTTP Connection Manager \u003cconfig_http_conn_man_runtime\u003e`. Default: 100%"
                },
                "random_sampling": {
                    "$ref": "#/definitions/envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "Target percentage of requests managed by this HTTP connection manager that will be randomly selected for trace generation, if not requested by the client or not forced. This field is a direct analog for the runtime variable 'tracing.random_sampling' in the :ref:`HTTP Connection Manager \u003cconfig_http_conn_man_runtime\u003e`. Default: 100%"
                },
                "overall_sampling": {
                    "$ref": "#/definitions/envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "Target percentage of requests managed by this HTTP connection manager that will be traced after all other sampling checks have been applied (client-directed, force tracing, random sampling). This field functions as an upper limit on the total configured sampling rate. For instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1% of client requests with the appropriate headers to be force traced. This field is a direct analog for the runtime variable 'tracing.global_enabled' in the :ref:`HTTP Connection Manager \u003cconfig_http_conn_man_runtime\u003e`. Default: 100%"
                },
                "custom_tags": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.tracing.v3.CustomTag"
                    },
                    "type": "array",
                    "description": "A list of custom tags with unique tag name to create tags for the active span. It will take effect after merging with the :ref:`corresponding configuration \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.custom_tags\u003e` configured in the HTTP connection manager. If two tags with the same name are configured each in the HTTP connection manager and the route level, the one configured here takes priority."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Tracing"
        },
        "envoy.config.route.v3.WeightedCluster": {
            "properties": {
                "clusters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.route.v3.WeightedCluster.ClusterWeight"
                    },
                    "type": "array",
                    "description": "Specifies one or more upstream clusters associated with the route."
                },
                "total_weight": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specifies the total weight across all clusters. The sum of all cluster weights must equal this value, if this is greater than 0. This field is now deprecated, and the client will use the sum of all cluster weights. It is up to the management server to supply the correct weights."
                },
                "runtime_key_prefix": {
                    "type": "string",
                    "description": "Specifies the runtime key prefix that should be used to construct the runtime keys associated with each cluster. When the ``runtime_key_prefix`` is specified, the router will look for weights associated with each upstream cluster under the key ``runtime_key_prefix`` + ``.`` + ``cluster[i].name`` where ``cluster[i]`` denotes an entry in the clusters array field. If the runtime key for the cluster does not exist, the value specified in the configuration file will be used as the default weight. See the :ref:`runtime documentation \u003coperations_runtime\u003e` for how key names map to the underlying implementation."
                },
                "header_name": {
                    "type": "string",
                    "description": "Specifies the header name that is used to look up the random value passed in the request header. This is used to ensure consistent cluster picking across multiple proxy levels for weighted traffic. If header is not present or invalid, Envoy will fall back to use the internally generated random value. This header is expected to be single-valued header as we only want to have one selected value throughout the process for the consistency. And the value is a unsigned number between 0 and UINT64_MAX."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Weighted Cluster",
            "description": "Compared to the :ref:`cluster \u003cenvoy_v3_api_field_config.route.v3.RouteAction.cluster\u003e` field that specifies a single upstream cluster as the target of a request, the :ref:`weighted_clusters \u003cenvoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters\u003e` option allows for specification of multiple upstream clusters along with weights that indicate the percentage of traffic to be forwarded to each cluster. The router selects an upstream cluster based on the weights."
        },
        "envoy.config.route.v3.WeightedCluster.ClusterWeight": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Only one of ``name`` and ``cluster_header`` may be specified. [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}] Name of the upstream cluster. The cluster must exist in the :ref:`cluster manager configuration \u003cconfig_cluster_manager\u003e`."
                },
                "cluster_header": {
                    "type": "string",
                    "description": "Only one of ``name`` and ``cluster_header`` may be specified. [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1 }] Envoy will determine the cluster to route to by reading the value of the HTTP header named by cluster_header from the request headers. If the header is not found or the referenced cluster does not exist, Envoy will return a 404 response. .. attention::   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead. .. note::   If the header appears multiple times only the first value is used."
                },
                "weight": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The weight of the cluster. This value is relative to the other clusters' weights. When a request matches the route, the choice of an upstream cluster is determined by its weight. The sum of weights across all entries in the clusters array must be greater than 0, and must not exceed uint32_t maximal value (4294967295)."
                },
                "metadata_match": {
                    "$ref": "#/definitions/envoy.config.core.v3.Metadata",
                    "additionalProperties": true,
                    "description": "Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in the upstream cluster with metadata matching what is set in this field will be considered for load balancing. Note that this will be merged with what's provided in :ref:`RouteAction.metadata_match \u003cenvoy_v3_api_field_config.route.v3.RouteAction.metadata_match\u003e`, with values here taking precedence. The filter name should be specified as ``envoy.lb``."
                },
                "request_headers_to_add": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HeaderValueOption"
                    },
                    "type": "array",
                    "description": "Specifies a list of headers to be added to requests when this cluster is selected through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`. Headers specified at this level are applied before headers from the enclosing :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on header value syntax, see the documentation on :ref:`custom request headers \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                },
                "request_headers_to_remove": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Specifies a list of HTTP headers that should be removed from each request when this cluster is selected through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`."
                },
                "response_headers_to_add": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HeaderValueOption"
                    },
                    "type": "array",
                    "description": "Specifies a list of headers to be added to responses when this cluster is selected through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`. Headers specified at this level are applied before headers from the enclosing :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on header value syntax, see the documentation on :ref:`custom request headers \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                },
                "response_headers_to_remove": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Specifies a list of headers to be removed from responses when this cluster is selected through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`."
                },
                "typed_per_filter_config": {
                    "additionalProperties": {
                        "properties": {
                            "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                            },
                            "value": {
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "binary",
                                "binaryEncoding": "base64"
                            }
                        },
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "This field can be used to provide weighted cluster specific per filter config. The key should match the :ref:`filter config name \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name\u003e`. See :ref:`Http filter route specific config \u003carch_overview_http_filters_per_filter_config\u003e` for details. [#comment: An entry's value may be wrapped in a :ref:`FilterConfig\u003cenvoy_v3_api_msg_config.route.v3.FilterConfig\u003e` message to specify additional options.]"
                },
                "host_rewrite_literal": {
                    "type": "string",
                    "description": "Indicates that during forwarding, the host header will be swapped with this value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Cluster Weight",
            "description": "[#next-free-field: 13]"
        },
        "envoy.type.matcher.v3.DoubleMatcher": {
            "properties": {
                "range": {
                    "$ref": "#/definitions/envoy.type.v3.DoubleRange",
                    "additionalProperties": true,
                    "description": "If specified, the input double value must be in the range specified here. Note: The range is using half-open interval semantics [start, end)."
                },
                "exact": {
                    "type": "number",
                    "description": "If specified, the input double value must be equal to the value specified here."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Number matcher]",
            "description": "[#protodoc-title: Number matcher]  Specifies the way to match a double value."
        },
        "envoy.type.matcher.v3.ListMatcher": {
            "properties": {
                "one_of": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher",
                    "additionalProperties": true,
                    "description": "If specified, at least one of the values in the list must match the value specified."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "List Matcher",
            "description": "Specifies the way to match a list value."
        },
        "envoy.type.matcher.v3.MetadataMatcher": {
            "properties": {
                "filter": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The filter name to retrieve the Struct from the Metadata."
                },
                "path": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.MetadataMatcher.PathSegment"
                    },
                    "type": "array",
                    "description": "The path to retrieve the Value from the Struct."
                },
                "value": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher",
                    "additionalProperties": true,
                    "description": "The MetadataMatcher is matched if the value retrieved by path is matched to this value."
                },
                "invert": {
                    "type": "boolean",
                    "description": "If true, the match result will be inverted."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "MetadataMatcher provides a general interface to check if a given value is matched in\n :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. It uses `filter` and `path` to retrieve the value\n from the Metadata and then check if it's matched to the specified value.\n\n For example, for the following Metadata:\n\n .. code-block:: yaml\n\n    filter_metadata:\n      envoy.filters.http.rbac:\n        fields:\n          a:\n            struct_value:\n              fields:\n                b:\n                  struct_value:\n                    fields:\n                      c:\n                        string_value: pro\n                t:\n                  list_value:\n                    values:\n                      - string_value: m\n                      - string_value: n\n\n The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value \"pro\"\n from the Metadata which is matched to the specified prefix match.\n\n .. code-block:: yaml\n\n    filter: envoy.filters.http.rbac\n    path:\n    - key: a\n    - key: b\n    - key: c\n    value:\n      string_match:\n        prefix: pr\n\n The following MetadataMatcher is matched as the code will match one of the string values in the\n list at the path [a, t].\n\n .. code-block:: yaml\n\n    filter: envoy.filters.http.rbac\n    path:\n    - key: a\n    - key: t\n    value:\n      list_match:\n        one_of:\n          string_match:\n            exact: m\n\n An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to\n enforce access control based on dynamic metadata in a request. See :ref:`Permission\n \u003cenvoy_v3_api_msg_config.rbac.v3.Permission\u003e` and :ref:`Principal\n \u003cenvoy_v3_api_msg_config.rbac.v3.Principal\u003e`.",
            "description": "[#protodoc-title: Metadata matcher]  MetadataMatcher provides a general interface to check if a given value is matched in :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. It uses `filter` and `path` to retrieve the value from the Metadata and then check if it's matched to the specified value. For example, for the following Metadata: .. code-block:: yaml    filter_metadata:      envoy.filters.http.rbac:        fields:          a:            struct_value:              fields:                b:                  struct_value:                    fields:                      c:                        string_value: pro                t:                  list_value:                    values:                      - string_value: m                      - string_value: n The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value \"pro\" from the Metadata which is matched to the specified prefix match. .. code-block:: yaml    filter: envoy.filters.http.rbac    path:    - key: a    - key: b    - key: c    value:      string_match:        prefix: pr The following MetadataMatcher is matched as the code will match one of the string values in the list at the path [a, t]. .. code-block:: yaml    filter: envoy.filters.http.rbac    path:    - key: a    - key: t    value:      list_match:        one_of:          string_match:            exact: m An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to enforce access control based on dynamic metadata in a request. See :ref:`Permission \u003cenvoy_v3_api_msg_config.rbac.v3.Permission\u003e` and :ref:`Principal \u003cenvoy_v3_api_msg_config.rbac.v3.Principal\u003e`.  [#next-major-version: MetadataMatcher should use StructMatcher]"
        },
        "envoy.type.matcher.v3.MetadataMatcher.PathSegment": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, use the key to retrieve the value in a Struct."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Path Segment",
            "description": "Specifies the segment in a path to retrieve value from Metadata. Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that if the segment key refers to a list, it has to be the last segment in a path."
        },
        "envoy.type.matcher.v3.OrMatcher": {
            "properties": {
                "value_matchers": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Or Matcher",
            "description": "Specifies a list of alternatives for the match."
        },
        "envoy.type.matcher.v3.RegexMatchAndSubstitute": {
            "properties": {
                "pattern": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "The regular expression used to find portions of a string (hereafter called the \"subject string\") that should be replaced. When a new string is produced during the substitution operation, the new string is initially the same as the subject string, but then all matches in the subject string are replaced by the substitution string. If replacing all matches isn't desired, regular expression anchors can be used to ensure a single match, so as to replace just one occurrence of a pattern. Capture groups can be used in the pattern to extract portions of the subject string, and then referenced in the substitution string."
                },
                "substitution": {
                    "type": "string",
                    "description": "The string that should be substituted into matching portions of the subject string during a substitution operation to produce a new string. Capture groups in the pattern can be referenced in the substitution string. Note, however, that the syntax for referring to capture groups is defined by the chosen regular expression engine. Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ regular expression engine uses a backslash followed by the capture group number to denote a numbered capture group. E.g., ``\\1`` refers to capture group 1, and ``\\2`` refers to capture group 2."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Regex Match And Substitute",
            "description": "Describes how to match a string and then produce a new string using a regular expression and a substitution string."
        },
        "envoy.type.matcher.v3.RegexMatcher": {
            "properties": {
                "google_re2": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher.GoogleRE2",
                    "additionalProperties": true,
                    "description": "Google's RE2 regex engine."
                },
                "regex": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The regex match string. The string must be supported by the configured engine. The regex is matched against the full string, not as a partial match."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Regex matcher]",
            "description": "[#protodoc-title: Regex matcher]  A regex matcher designed for safety when used with untrusted input."
        },
        "envoy.type.matcher.v3.RegexMatcher.GoogleRE2": {
            "properties": {
                "max_program_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "This field controls the RE2 \"program size\" which is a rough estimate of how complex a compiled regex is to evaluate. A regex that has a program size greater than the configured value will fail to compile. In this case, the configured max program size can be increased or the regex can be simplified. If not specified, the default is 100. This field is deprecated; regexp validation should be performed on the management server instead of being done by each individual client. .. note::  Although this field is deprecated, the program size will still be checked against the  global ``re2.max_program_size.error_level`` runtime value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Google RE 2",
            "description": "Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ regex engine. The regex string must adhere to the documented `syntax \u003chttps://github.com/google/re2/wiki/Syntax\u003e`_. The engine is designed to complete execution in linear time as well as limit the amount of memory used. Envoy supports program size checking via runtime. The runtime keys ``re2.max_program_size.error_level`` and ``re2.max_program_size.warn_level`` can be set to integers as the maximum program size or complexity that a compiled regex can have before an exception is thrown or a warning is logged, respectively. ``re2.max_program_size.error_level`` defaults to 100, and ``re2.max_program_size.warn_level`` has no default if unset (will not check/log a warning). Envoy emits two stats for tracking the program size of regexes: the histogram ``re2.program_size``, which records the program size, and the counter ``re2.exceeded_warn_level``, which is incremented each time the program size exceeds the warn level threshold."
        },
        "envoy.type.matcher.v3.StringMatcher": {
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "The input string must match exactly the string specified here. Examples: * ``abc`` only matches the value ``abc``."
                },
                "prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``abc.xyz``"
                },
                "suffix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``xyz.abc``"
                },
                "safe_regex": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "The input string must match the regular expression specified here."
                },
                "contains": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``xyz.abc.def``"
                },
                "custom": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Use an extension as the matcher type. [#extension-category: envoy.string_matcher]"
                },
                "ignore_case": {
                    "type": "boolean",
                    "description": "If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. This has no effect for the safe_regex match. For example, the matcher ``data`` will match both input string ``Data`` and ``data`` if set to true."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: String matcher]",
            "description": "[#protodoc-title: String matcher]  Specifies the way to match a string. [#next-free-field: 9]"
        },
        "envoy.type.matcher.v3.ValueMatcher": {
            "properties": {
                "null_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher.NullMatch",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a NullValue."
                },
                "double_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.DoubleMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a double value and is matched to this field."
                },
                "string_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a string value and is matched to this field."
                },
                "bool_match": {
                    "type": "boolean",
                    "description": "If specified, a match occurs if and only if the target value is a bool value and is equal to this field."
                },
                "present_match": {
                    "type": "boolean",
                    "description": "If specified, value match will be performed based on whether the path is referring to a valid primitive value in the metadata. If the path is referring to a non-primitive value, the result is always not matched."
                },
                "list_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ListMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a list value and is matched to this field."
                },
                "or_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.OrMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if any of the alternatives in the match accept the value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Value matcher]",
            "description": "[#protodoc-title: Value matcher]  Specifies the way to match a ProtobufWkt::Value. Primitive values and ListValue are supported. StructValue is not supported and is always not matched. [#next-free-field: 8]"
        },
        "envoy.type.matcher.v3.ValueMatcher.NullMatch": {
            "additionalProperties": true,
            "type": "object",
            "title": "Null Match",
            "description": "NullMatch is an empty message to specify a null value."
        },
        "envoy.type.metadata.v3.MetadataKey": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The key name of Metadata to retrieve the Struct from the metadata. Typically, it represents a builtin subsystem or custom extension."
                },
                "path": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKey.PathSegment"
                    },
                    "type": "array",
                    "description": "The path to retrieve the Value from the Struct. It can be a prefix or a full path, e.g. ``[prop, xyz]`` for a struct or ``[prop, foo]`` for a string in the example, which depends on the particular scenario. Note: Due to that only the key type segment is supported, the path can not specify a list unless the list is the last segment."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Metadata]",
            "description": "[#protodoc-title: Metadata]  MetadataKey provides a general interface using ``key`` and ``path`` to retrieve value from :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. For example, for the following Metadata: .. code-block:: yaml    filter_metadata:      envoy.xxx:        prop:          foo: bar          xyz:            hello: envoy The following MetadataKey will retrieve a string value \"bar\" from the Metadata. .. code-block:: yaml    key: envoy.xxx    path:    - key: prop    - key: foo"
        },
        "envoy.type.metadata.v3.MetadataKey.PathSegment": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, use the key to retrieve the value in a Struct."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Path Segment",
            "description": "Specifies the segment in a path to retrieve value from Metadata. Currently it is only supported to specify the key, i.e. field name, as one segment of a path."
        },
        "envoy.type.metadata.v3.MetadataKind": {
            "properties": {
                "request": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKind.Request",
                    "additionalProperties": true,
                    "description": "Request kind of metadata."
                },
                "route": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKind.Route",
                    "additionalProperties": true,
                    "description": "Route kind of metadata."
                },
                "cluster": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKind.Cluster",
                    "additionalProperties": true,
                    "description": "Cluster kind of metadata."
                },
                "host": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKind.Host",
                    "additionalProperties": true,
                    "description": "Host kind of metadata."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata Kind",
            "description": "Describes what kind of metadata."
        },
        "envoy.type.metadata.v3.MetadataKind.Cluster": {
            "additionalProperties": true,
            "type": "object",
            "title": "Cluster",
            "description": "Represents metadata from :ref:`the upstream cluster\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.metadata\u003e`."
        },
        "envoy.type.metadata.v3.MetadataKind.Host": {
            "additionalProperties": true,
            "type": "object",
            "title": "Host",
            "description": "Represents metadata from :ref:`the upstream host\u003cenvoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata\u003e`."
        },
        "envoy.type.metadata.v3.MetadataKind.Request": {
            "additionalProperties": true,
            "type": "object",
            "title": "Request",
            "description": "Represents dynamic metadata associated with the request."
        },
        "envoy.type.metadata.v3.MetadataKind.Route": {
            "additionalProperties": true,
            "type": "object",
            "title": "Route",
            "description": "Represents metadata from :ref:`the route\u003cenvoy_v3_api_field_config.route.v3.Route.metadata\u003e`."
        },
        "envoy.type.tracing.v3.CustomTag": {
            "properties": {
                "tag": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Used to populate the tag name."
                },
                "literal": {
                    "$ref": "#/definitions/envoy.type.tracing.v3.CustomTag.Literal",
                    "additionalProperties": true,
                    "description": "A literal custom tag."
                },
                "environment": {
                    "$ref": "#/definitions/envoy.type.tracing.v3.CustomTag.Environment",
                    "additionalProperties": true,
                    "description": "An environment custom tag."
                },
                "request_header": {
                    "$ref": "#/definitions/envoy.type.tracing.v3.CustomTag.Header",
                    "additionalProperties": true,
                    "description": "A request header custom tag."
                },
                "metadata": {
                    "$ref": "#/definitions/envoy.type.tracing.v3.CustomTag.Metadata",
                    "additionalProperties": true,
                    "description": "A custom tag to obtain tag value from the metadata."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Custom Tag]",
            "description": "[#protodoc-title: Custom Tag]  Describes custom tags for the active span. [#next-free-field: 6]"
        },
        "envoy.type.tracing.v3.CustomTag.Environment": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Environment variable name to obtain the value to populate the tag value."
                },
                "default_value": {
                    "type": "string",
                    "description": "When the environment variable is not found, the tag value will be populated with this default value if specified, otherwise no tag will be populated."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Environment",
            "description": "Environment type custom tag with environment name and default value."
        },
        "envoy.type.tracing.v3.CustomTag.Header": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Header name to obtain the value to populate the tag value."
                },
                "default_value": {
                    "type": "string",
                    "description": "When the header does not exist, the tag value will be populated with this default value if specified, otherwise no tag will be populated."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header",
            "description": "Header type custom tag with header name and default value."
        },
        "envoy.type.tracing.v3.CustomTag.Literal": {
            "properties": {
                "value": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Static literal value to populate the tag value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Literal",
            "description": "Literal type custom tag with static value for the tag value."
        },
        "envoy.type.tracing.v3.CustomTag.Metadata": {
            "properties": {
                "kind": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKind",
                    "additionalProperties": true,
                    "description": "Specify what kind of metadata to obtain tag value from."
                },
                "metadata_key": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKey",
                    "additionalProperties": true,
                    "description": "Metadata key to define the path to retrieve the tag value."
                },
                "default_value": {
                    "type": "string",
                    "description": "When no valid metadata is found, the tag value would be populated with this default value if specified, otherwise no tag would be populated."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Metadata type custom tag using :ref:`MetadataKey \u003cenvoy_v3_api_msg_type.metadata.v3.MetadataKey\u003e` to retrieve the protobuf value from :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`, and populate the tag value with `the canonical JSON \u003chttps://developers.google.com/protocol-buffers/docs/proto3#json\u003e`_ representation of it."
        },
        "envoy.type.v3.DoubleRange": {
            "properties": {
                "start": {
                    "type": "number",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "number",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Double Range",
            "description": "Specifies the double start and end of the range using half-open interval semantics [start, end)."
        },
        "envoy.type.v3.FractionalPercent": {
            "properties": {
                "numerator": {
                    "type": "integer",
                    "description": "Specifies the numerator. Defaults to 0."
                },
                "denominator": {
                    "enum": [
                        "HUNDRED",
                        0,
                        "TEN_THOUSAND",
                        1,
                        "MILLION",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Denominator Type",
                    "description": "Fraction percentages support several fixed denominator values."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Fractional Percent",
            "description": "A fractional percentage is used in cases in which for performance reasons performing floating point to integer conversions during randomness calculations is undesirable. The message includes both a numerator and denominator that together determine the final fractional value. * **Example**: 1/100 = 1%. * **Example**: 3/10000 = 0.03%."
        },
        "envoy.type.v3.Int64Range": {
            "properties": {
                "start": {
                    "type": "string",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "string",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Range]",
            "description": "[#protodoc-title: Range]  Specifies the int64 start and end of the range using half-open interval semantics [start, end)."
        },
        "xds.core.v3.TypedExtensionConfig": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of an extension. This is not used to select the extension, instead it serves the role of an opaque identifier."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The typed config for the extension. The type URL will be used to identify the extension. In the case that the type URL is *xds.type.v3.TypedStruct* (or, for historical reasons, *udpa.type.v1.TypedStruct*), the inner type URL of *TypedStruct* will be utilized. See the :ref:`extension configuration overview \u003cconfig_overview_extension_configuration\u003e` for further details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Typed Extension Config",
            "description": "Message type for extension configuration."
        }
    }
}