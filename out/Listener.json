{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "$ref": "#/definitions/Listener",
    "definitions": {
        "Listener": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The unique name by which this listener is known. If no name is provided, Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically updated or removed via :ref:`LDS \u003cconfig_listeners_lds\u003e` a unique name must be provided."
                },
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.Address",
                    "additionalProperties": true,
                    "description": "The address that the listener should listen on. In general, the address must be unique, though that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on Linux as the actual port will be allocated by the OS. Required unless ``api_listener`` or ``listener_specifier`` is populated."
                },
                "additional_addresses": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.AdditionalAddress"
                    },
                    "type": "array",
                    "description": "The additional addresses the listener should listen on. The addresses must be unique across all listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener, all addresses use the same protocol, and multiple internal addresses are not supported."
                },
                "stat_prefix": {
                    "type": "string",
                    "description": "Optional prefix to use on listener stats. If empty, the stats will be rooted at ``listener.\u003caddress as string\u003e.``. If non-empty, stats will be rooted at ``listener.\u003cstat_prefix\u003e.``."
                },
                "filter_chains": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.FilterChain"
                    },
                    "type": "array",
                    "description": "A list of filter chains to consider for this listener. The :ref:`FilterChain \u003cenvoy_v3_api_msg_config.listener.v3.FilterChain\u003e` with the most specific :ref:`FilterChainMatch \u003cenvoy_v3_api_msg_config.listener.v3.FilterChainMatch\u003e` criteria is used on a connection. Example using SNI for filter chain selection can be found in the :ref:`FAQ entry \u003cfaq_how_to_setup_sni\u003e`."
                },
                "filter_chain_matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher",
                    "additionalProperties": true,
                    "description": ":ref:`Matcher API \u003carch_overview_matching_listener\u003e` resolving the filter chain name from the network properties. This matcher is used as a replacement for the filter chain match condition :ref:`filter_chain_match \u003cenvoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match\u003e`. If specified, all :ref:`filter_chains \u003cenvoy_v3_api_field_config.listener.v3.Listener.filter_chains\u003e` must have a non-empty and unique :ref:`name \u003cenvoy_v3_api_field_config.listener.v3.FilterChain.name\u003e` field and not specify :ref:`filter_chain_match \u003cenvoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match\u003e` field. .. note::  Once matched, each connection is permanently bound to its filter chain.  If the matcher changes but the filter chain remains the same, the  connections bound to the filter chain are not drained. If, however, the  filter chain is removed or structurally modified, then the drain for its  connections is initiated."
                },
                "use_original_dst": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "If a connection is redirected using ``iptables``, the port on which the proxy receives it might be different from the original destination address. When this flag is set to true, the listener hands off redirected connections to the listener associated with the original destination address. If there is no listener associated with the original destination address, the connection is handled by the listener that receives it. Defaults to false."
                },
                "default_filter_chain": {
                    "$ref": "#/definitions/envoy.config.listener.v3.FilterChain",
                    "additionalProperties": true,
                    "description": "The default filter chain if none of the filter chain matches. If no default filter chain is supplied, the connection will be closed. The filter chain match is ignored in this field."
                },
                "per_connection_buffer_limit_bytes": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Soft limit on size of the listener’s new connection read and write buffers. If unspecified, an implementation defined default is applied (1MiB)."
                },
                "metadata": {
                    "$ref": "#/definitions/envoy.config.core.v3.Metadata",
                    "additionalProperties": true,
                    "description": "Listener metadata."
                },
                "deprecated_v1": {
                    "$ref": "#/definitions/envoy.config.listener.v3.Listener.DeprecatedV1",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:]"
                },
                "drain_type": {
                    "enum": [
                        "DEFAULT",
                        0,
                        "MODIFY_ONLY",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Drain Type"
                },
                "listener_filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilter"
                    },
                    "type": "array",
                    "description": "Listener filters have the opportunity to manipulate and augment the connection metadata that is used in connection filter chain matching, for example. These filters are run before any in :ref:`filter_chains \u003cenvoy_v3_api_field_config.listener.v3.Listener.filter_chains\u003e`. Order matters as the filters are processed sequentially right after a socket has been accepted by the listener, and before a connection is created. UDP Listener filters can be specified when the protocol in the listener socket address in :ref:`protocol \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.protocol\u003e` is :ref:`UDP \u003cenvoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP\u003e` and no :ref:`quic_options \u003cenvoy_v3_api_field_config.listener.v3.UdpListenerConfig.quic_options\u003e` is specified in :ref:`udp_listener_config \u003cenvoy_v3_api_field_config.listener.v3.Listener.udp_listener_config\u003e`. QUIC listener filters can be specified when :ref:`quic_options \u003cenvoy_v3_api_field_config.listener.v3.UdpListenerConfig.quic_options\u003e` is specified in :ref:`udp_listener_config \u003cenvoy_v3_api_field_config.listener.v3.Listener.udp_listener_config\u003e`. They are processed sequentially right before connection creation. And like TCP Listener filters, they can be used to manipulate the connection metadata and socket. But the difference is that they can't be used to pause connection creation."
                },
                "listener_filters_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The timeout to wait for all listener filters to complete operation. If the timeout is reached, the accepted socket is closed without a connection being created unless ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the timeout. If not specified, a default timeout of 15s is used.",
                    "format": "regex"
                },
                "continue_on_listener_filters_timeout": {
                    "type": "boolean",
                    "description": "Whether a connection should be created when listener filters timeout. Default is false. .. attention::   Some listener filters, such as :ref:`Proxy Protocol filter   \u003cconfig_listener_filters_proxy_protocol\u003e`, should not be used with this option. It will cause   unexpected behavior when a connection is created."
                },
                "transparent": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should be set as a transparent socket. When this flag is set to true, connections can be redirected to the listener using an ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and ports are preserved on accepted connections. This flag should be used in combination with :ref:`an original_dst \u003cconfig_listener_filters_original_dst\u003e` :ref:`listener filter \u003cenvoy_v3_api_field_config.listener.v3.Listener.listener_filters\u003e` to mark the connections' local addresses as \"restored.\" This can be used to hand off each redirected connection to another listener associated with the connection's destination address. Direct connections to the socket without using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are therefore treated as if they were redirected. When this flag is set to false, the listener's socket is explicitly reset as non-transparent. Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability. When this flag is not set (default), the socket is not modified, i.e. the transparent option is neither set nor reset."
                },
                "freebind": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should set the ``IP_FREEBIND`` socket option. When this flag is set to true, listeners can be bound to an IP address that is not configured on the system running Envoy. When this flag is set to false, the option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set (default), the socket is not modified, i.e. the option is neither enabled nor disabled."
                },
                "socket_options": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.SocketOption"
                    },
                    "type": "array",
                    "description": "Additional socket options that may not be present in Envoy source code or precompiled binaries. The socket options can be updated for a listener when :ref:`enable_reuse_port \u003cenvoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port\u003e` is ``true``. Otherwise, if socket options change during a listener update the update will be rejected to make it clear that the options were not updated."
                },
                "tcp_fast_open_queue_length": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Whether the listener should accept TCP Fast Open (TFO) connections. When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on the socket, with a queue length of the specified size (see `details in RFC7413 \u003chttps://tools.ietf.org/html/rfc7413#section-5.1\u003e`_). When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket. When this flag is not set (default), the socket is not modified, i.e. the option is neither enabled nor disabled. On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable TCP_FASTOPEN. See `ip-sysctl.txt \u003chttps://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt\u003e`_. On macOS, only values of 0, 1, and unset are valid; other values may result in an error. To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter."
                },
                "traffic_direction": {
                    "enum": [
                        "UNSPECIFIED",
                        0,
                        "INBOUND",
                        1,
                        "OUTBOUND",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Traffic Direction",
                    "description": "Identifies the direction of the traffic relative to the local Envoy."
                },
                "udp_listener_config": {
                    "$ref": "#/definitions/envoy.config.listener.v3.UdpListenerConfig",
                    "additionalProperties": true,
                    "description": "If the protocol in the listener socket address in :ref:`protocol \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.protocol\u003e` is :ref:`UDP \u003cenvoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP\u003e`, this field specifies UDP listener specific configuration."
                },
                "api_listener": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ApiListener",
                    "additionalProperties": true,
                    "description": "Used to represent an API listener, which is used in non-proxy clients. The type of API exposed to the non-proxy application depends on the type of API listener. When this field is set, no other field except for :ref:`name\u003cenvoy_v3_api_field_config.listener.v3.Listener.name\u003e` should be set. .. note::  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,  not LDS. [#next-major-version: In the v3 API, instead of this messy approach where the socket listener fields are directly in the top-level Listener message and the API listener types are in the ApiListener message, the socket listener messages should be in their own message, and the top-level Listener should essentially be a oneof that selects between the socket listener and the various types of API listener. That way, a given Listener message can structurally only contain the fields of the relevant type.]"
                },
                "connection_balance_config": {
                    "$ref": "#/definitions/envoy.config.listener.v3.Listener.ConnectionBalanceConfig",
                    "additionalProperties": true,
                    "description": "The listener's connection balancer configuration, currently only applicable to TCP listeners. If no configuration is specified, Envoy will not attempt to balance active connections between worker threads. In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2 by setting :ref:`use_original_dst \u003cenvoy_v3_api_field_config.listener.v3.Listener.use_original_dst\u003e` in X and :ref:`bind_to_port \u003cenvoy_v3_api_field_config.listener.v3.Listener.bind_to_port\u003e` to false in Y1 and Y2, it is recommended to disable the balance config in listener X to avoid the cost of balancing, and enable the balance config in Y1 and Y2 to balance the connections among the workers."
                },
                "reuse_port": {
                    "type": "boolean",
                    "description": "Deprecated. Use ``enable_reuse_port`` instead."
                },
                "enable_reuse_port": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and create one socket for each worker thread. This makes inbound connections distribute among worker threads roughly evenly in cases where there are a high number of connections. When this flag is set to false, all worker threads share one socket. This field defaults to true. The change of field will be rejected during an listener update when the runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled. Otherwise, the update of this field will be ignored quietly. .. attention::   Although this field defaults to true, it has different behavior on different platforms. See   the following text for more information. * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly   with hot restart. * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,   the last socket wins and receives all connections/packets. For TCP, reuse_port is force   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive   packets. For QUIC/H3, SW routing will send packets to other workers. For \"raw\" UDP, only   a single worker will currently receive packets. * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently."
                },
                "access_log": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLog"
                    },
                    "type": "array",
                    "description": "Configuration for :ref:`access logs \u003carch_overview_access_logs\u003e` emitted by this listener."
                },
                "tcp_backlog_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum length a tcp listener's pending connections queue can grow to. If no value is provided net.core.somaxconn will be used on Linux and 128 otherwise."
                },
                "max_connections_to_accept_per_socket_event": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum number of connections to accept from the kernel per socket event. Envoy may decide to close these connections after accepting them from the kernel e.g. due to load shedding, or other policies. If there are more than max_connections_to_accept_per_socket_event connections pending accept, connections over this threshold will be accepted in later event loop iterations. If no value is provided Envoy will accept all connections pending accept from the kernel."
                },
                "bind_to_port": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should bind to the port. A listener that doesn't bind can only receive connections redirected from other listeners that set :ref:`use_original_dst \u003cenvoy_v3_api_field_config.listener.v3.Listener.use_original_dst\u003e` to true. Default is true."
                },
                "internal_listener": {
                    "$ref": "#/definitions/envoy.config.listener.v3.Listener.InternalListenerConfig",
                    "additionalProperties": true,
                    "description": "Used to represent an internal listener which does not listen on OSI L4 address but can be used by the :ref:`envoy cluster \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e` to create a user space connection to. The internal listener acts as a TCP listener. It supports listener filters and network filter chains. Upstream clusters refer to the internal listeners by their :ref:`name \u003cenvoy_v3_api_field_config.listener.v3.Listener.name\u003e`. :ref:`Address \u003cenvoy_v3_api_field_config.listener.v3.Listener.address\u003e` must not be set on the internal listeners. There are some limitations that are derived from the implementation. The known limitations include: * :ref:`ConnectionBalanceConfig \u003cenvoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig\u003e` is not   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher. * :ref:`tcp_backlog_size \u003cenvoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size\u003e` * :ref:`freebind \u003cenvoy_v3_api_field_config.listener.v3.Listener.freebind\u003e` * :ref:`transparent \u003cenvoy_v3_api_field_config.listener.v3.Listener.transparent\u003e`"
                },
                "enable_mptcp": {
                    "type": "boolean",
                    "description": "Enable MPTCP (multi-path TCP) on this listener. Clients will be allowed to establish MPTCP connections. Non-MPTCP clients will fall back to regular TCP."
                },
                "ignore_global_conn_limit": {
                    "type": "boolean",
                    "description": "Whether the listener should limit connections based upon the value of :ref:`global_downstream_max_connections \u003cconfig_overload_manager_limiting_connections\u003e`."
                },
                "bypass_overload_manager": {
                    "type": "boolean",
                    "description": "Whether the listener bypasses configured overload manager actions."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Listener",
            "description": "[#next-free-field: 36]"
        },
        "envoy.config.accesslog.v3.AccessLog": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the access log extension configuration."
                },
                "filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLogFilter",
                    "additionalProperties": true,
                    "description": "Filter which is used to determine if the access log needs to be written."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Common access log types]",
            "description": "[#protodoc-title: Common access log types]"
        },
        "envoy.config.accesslog.v3.AccessLogFilter": {
            "properties": {
                "status_code_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.StatusCodeFilter",
                    "additionalProperties": true,
                    "description": "Status code filter."
                },
                "duration_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.DurationFilter",
                    "additionalProperties": true,
                    "description": "Duration filter."
                },
                "not_health_check_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.NotHealthCheckFilter",
                    "additionalProperties": true,
                    "description": "Not health check filter."
                },
                "traceable_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.TraceableFilter",
                    "additionalProperties": true,
                    "description": "Traceable filter."
                },
                "runtime_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.RuntimeFilter",
                    "additionalProperties": true,
                    "description": "Runtime filter."
                },
                "and_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.AndFilter",
                    "additionalProperties": true,
                    "description": "And filter."
                },
                "or_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.OrFilter",
                    "additionalProperties": true,
                    "description": "Or filter."
                },
                "header_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.HeaderFilter",
                    "additionalProperties": true,
                    "description": "Header filter."
                },
                "response_flag_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ResponseFlagFilter",
                    "additionalProperties": true,
                    "description": "Response flag filter."
                },
                "grpc_status_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.GrpcStatusFilter",
                    "additionalProperties": true,
                    "description": "gRPC status filter."
                },
                "extension_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ExtensionFilter",
                    "additionalProperties": true,
                    "description": "Extension filter. [#extension-category: envoy.access_loggers.extension_filters]"
                },
                "metadata_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.MetadataFilter",
                    "additionalProperties": true,
                    "description": "Metadata Filter"
                },
                "log_type_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.LogTypeFilter",
                    "additionalProperties": true,
                    "description": "Log Type Filter"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Access Log Filter",
            "description": "[#next-free-field: 14]"
        },
        "envoy.config.accesslog.v3.AndFilter": {
            "properties": {
                "filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLogFilter"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "And Filter",
            "description": "Performs a logical “and” operation on the result of each filter in filters. Filters are evaluated sequentially and if one of them returns false, the filter returns false immediately."
        },
        "envoy.config.accesslog.v3.ComparisonFilter": {
            "properties": {
                "op": {
                    "enum": [
                        "EQ",
                        0,
                        "GE",
                        1,
                        "LE",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Op"
                },
                "value": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeUInt32",
                    "additionalProperties": true,
                    "description": "Value to compare against."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Comparison Filter",
            "description": "Filter on an integer comparison."
        },
        "envoy.config.accesslog.v3.DurationFilter": {
            "properties": {
                "comparison": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ComparisonFilter",
                    "additionalProperties": true,
                    "description": "Comparison."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Duration Filter",
            "description": "Filters based on the duration of the request or stream, in milliseconds. For end of stream access logs, the total duration of the stream will be used. For :ref:`periodic access logs\u003carch_overview_access_log_periodic\u003e`, the duration of the stream at the time of log recording will be used."
        },
        "envoy.config.accesslog.v3.ExtensionFilter": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the filter implementation to instantiate. The name must match a statically registered filter."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Extension Filter",
            "description": "Extension filter is statically registered at runtime."
        },
        "envoy.config.accesslog.v3.GrpcStatusFilter": {
            "properties": {
                "statuses": {
                    "items": {
                        "enum": [
                            "OK",
                            0,
                            "CANCELED",
                            1,
                            "UNKNOWN",
                            2,
                            "INVALID_ARGUMENT",
                            3,
                            "DEADLINE_EXCEEDED",
                            4,
                            "NOT_FOUND",
                            5,
                            "ALREADY_EXISTS",
                            6,
                            "PERMISSION_DENIED",
                            7,
                            "RESOURCE_EXHAUSTED",
                            8,
                            "FAILED_PRECONDITION",
                            9,
                            "ABORTED",
                            10,
                            "OUT_OF_RANGE",
                            11,
                            "UNIMPLEMENTED",
                            12,
                            "INTERNAL",
                            13,
                            "UNAVAILABLE",
                            14,
                            "DATA_LOSS",
                            15,
                            "UNAUTHENTICATED",
                            16
                        ]
                    },
                    "type": "array",
                    "title": "Status"
                },
                "exclude": {
                    "type": "boolean",
                    "description": "If included and set to true, the filter will instead block all responses with a gRPC status or inferred gRPC status enumerated in statuses, and allow all other responses."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Grpc Status Filter",
            "description": "Filters gRPC requests based on their response status. If a gRPC status is not provided, the filter will infer the status from the HTTP status code."
        },
        "envoy.config.accesslog.v3.HeaderFilter": {
            "properties": {
                "header": {
                    "$ref": "#/definitions/envoy.config.route.v3.HeaderMatcher",
                    "additionalProperties": true,
                    "description": "Only requests with a header which matches the specified HeaderMatcher will pass the filter check."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Filter",
            "description": "Filters requests based on the presence or value of a request header."
        },
        "envoy.config.accesslog.v3.LogTypeFilter": {
            "properties": {
                "types": {
                    "items": {
                        "enum": [
                            "NotSet",
                            0,
                            "TcpUpstreamConnected",
                            1,
                            "TcpPeriodic",
                            2,
                            "TcpConnectionEnd",
                            3,
                            "DownstreamStart",
                            4,
                            "DownstreamPeriodic",
                            5,
                            "DownstreamEnd",
                            6,
                            "UpstreamPoolReady",
                            7,
                            "UpstreamPeriodic",
                            8,
                            "UpstreamEnd",
                            9,
                            "DownstreamTunnelSuccessfullyEstablished",
                            10,
                            "UdpTunnelUpstreamConnected",
                            11,
                            "UdpPeriodic",
                            12,
                            "UdpSessionEnd",
                            13
                        ]
                    },
                    "type": "array",
                    "title": "[#protodoc-title: gRPC access logs]\n Envoy access logs describe incoming interaction with Envoy over a fixed\n period of time, and typically cover a single request/response exchange,\n (e.g. HTTP), stream (e.g. over HTTP/gRPC), or proxied connection (e.g. TCP).\n Access logs contain fields defined in protocol-specific protobuf messages.\n\n Except where explicitly declared otherwise, all fields describe\n *downstream* interaction between Envoy and a connected client.\n Fields describing *upstream* interaction will explicitly include ``upstream``\n in their name.",
                    "description": "[#protodoc-title: gRPC access logs] Envoy access logs describe incoming interaction with Envoy over a fixed period of time, and typically cover a single request/response exchange, (e.g. HTTP), stream (e.g. over HTTP/gRPC), or proxied connection (e.g. TCP). Access logs contain fields defined in protocol-specific protobuf messages. Except where explicitly declared otherwise, all fields describe *downstream* interaction between Envoy and a connected client. Fields describing *upstream* interaction will explicitly include ``upstream`` in their name."
                },
                "exclude": {
                    "type": "boolean",
                    "description": "If this field is set to true, the filter will instead block all records with a access log type in types field, and allow all other records."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Log Type Filter",
            "description": "Filters based on access log type."
        },
        "envoy.config.accesslog.v3.MetadataFilter": {
            "properties": {
                "matcher": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.MetadataMatcher",
                    "additionalProperties": true,
                    "description": "Matcher to check metadata for specified value. For example, to match on the access_log_hint metadata, set the filter to \"envoy.common\" and the path to \"access_log_hint\", and the value to \"true\"."
                },
                "match_if_key_not_found": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Default result if the key does not exist in dynamic metadata: if unset or true, then log; if false, then don't log."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata Filter",
            "description": "Filters based on matching dynamic metadata. If the matcher path and key correspond to an existing key in dynamic metadata, the request is logged only if the matcher value is equal to the metadata value. If the matcher path and key *do not* correspond to an existing key in dynamic metadata, the request is logged only if match_if_key_not_found is \"true\" or unset."
        },
        "envoy.config.accesslog.v3.NotHealthCheckFilter": {
            "additionalProperties": true,
            "type": "object",
            "title": "Not Health Check Filter",
            "description": "Filters for requests that are not health check requests. A health check request is marked by the health check filter."
        },
        "envoy.config.accesslog.v3.OrFilter": {
            "properties": {
                "filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLogFilter"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Or Filter",
            "description": "Performs a logical “or” operation on the result of each individual filter. Filters are evaluated sequentially and if one of them returns true, the filter returns true immediately."
        },
        "envoy.config.accesslog.v3.ResponseFlagFilter": {
            "properties": {
                "flags": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Only responses with the any of the flags listed in this field will be logged. This field is optional. If it is not specified, then any response flag will pass the filter check."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Response Flag Filter",
            "description": "Filters requests that received responses with an Envoy response flag set. A list of the response flags can be found in the access log formatter :ref:`documentation\u003cconfig_access_log_format_response_flags\u003e`."
        },
        "envoy.config.accesslog.v3.RuntimeFilter": {
            "properties": {
                "runtime_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Runtime key to get an optional overridden numerator for use in the ``percent_sampled`` field. If found in runtime, this value will replace the default numerator."
                },
                "percent_sampled": {
                    "$ref": "#/definitions/envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "The default sampling percentage. If not specified, defaults to 0% with denominator of 100."
                },
                "use_independent_randomness": {
                    "type": "boolean",
                    "description": "By default, sampling pivots on the header :ref:`x-request-id\u003cconfig_http_conn_man_headers_x-request-id\u003e` being present. If :ref:`x-request-id\u003cconfig_http_conn_man_headers_x-request-id\u003e` is present, the filter will consistently sample across multiple hosts based on the runtime key value and the value extracted from :ref:`x-request-id\u003cconfig_http_conn_man_headers_x-request-id\u003e`. If it is missing, or ``use_independent_randomness`` is set to true, the filter will randomly sample based on the runtime key value alone. ``use_independent_randomness`` can be used for logging kill switches within complex nested :ref:`AndFilter \u003cenvoy_v3_api_msg_config.accesslog.v3.AndFilter\u003e` and :ref:`OrFilter \u003cenvoy_v3_api_msg_config.accesslog.v3.OrFilter\u003e` blocks that are easier to reason about from a probability perspective (i.e., setting to true will cause the filter to behave like an independent random variable when composed within logical operator filters)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime Filter",
            "description": "Filters for random sampling of requests."
        },
        "envoy.config.accesslog.v3.StatusCodeFilter": {
            "properties": {
                "comparison": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ComparisonFilter",
                    "additionalProperties": true,
                    "description": "Comparison."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Status Code Filter",
            "description": "Filters on HTTP response/status code."
        },
        "envoy.config.accesslog.v3.TraceableFilter": {
            "additionalProperties": true,
            "type": "object",
            "title": "Traceable Filter",
            "description": "Filters for requests that are traceable. See the tracing overview for more information on how a request becomes traceable."
        },
        "envoy.config.core.v3.Address": {
            "properties": {
                "socket_address": {
                    "$ref": "#/definitions/envoy.config.core.v3.SocketAddress",
                    "additionalProperties": true
                },
                "pipe": {
                    "$ref": "#/definitions/envoy.config.core.v3.Pipe",
                    "additionalProperties": true
                },
                "envoy_internal_address": {
                    "$ref": "#/definitions/envoy.config.core.v3.EnvoyInternalAddress",
                    "additionalProperties": true,
                    "description": "Specifies a user-space address handled by :ref:`internal listeners \u003cenvoy_v3_api_field_config.listener.v3.Listener.internal_listener\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Address",
            "description": "Addresses specify either a logical or physical address and port, which are used to tell Envoy where to bind/listen, connect to upstream and find management servers."
        },
        "envoy.config.core.v3.AggregatedConfigSource": {
            "additionalProperties": true,
            "type": "object",
            "title": "Aggregated Config Source",
            "description": "Aggregated Discovery Service (ADS) options. This is currently empty, but when set in :ref:`ConfigSource \u003cenvoy_v3_api_msg_config.core.v3.ConfigSource\u003e` can be used to specify that ADS is to be used."
        },
        "envoy.config.core.v3.ApiConfigSource": {
            "properties": {
                "api_type": {
                    "enum": [
                        "DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE",
                        0,
                        "REST",
                        1,
                        "GRPC",
                        2,
                        "DELTA_GRPC",
                        3,
                        "AGGREGATED_GRPC",
                        5,
                        "AGGREGATED_DELTA_GRPC",
                        6
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Api Type",
                    "description": "APIs may be fetched via either REST or gRPC."
                },
                "transport_api_version": {
                    "enum": [
                        "AUTO",
                        0,
                        "V2",
                        1,
                        "V3",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: Configuration sources]",
                    "description": "[#protodoc-title: Configuration sources]  xDS API and non-xDS services version. This is used to describe both resource and transport protocol versions (in distinct configuration fields)."
                },
                "cluster_names": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Cluster names should be used only with REST. If \u003e 1 cluster is defined, clusters will be cycled through if any kind of failure occurs. .. note::  The cluster with name ``cluster_name`` must be statically defined and its  type must not be ``EDS``."
                },
                "grpc_services": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.GrpcService"
                    },
                    "type": "array",
                    "description": "Multiple gRPC services be provided for GRPC. If \u003e 1 cluster is defined, services will be cycled through if any kind of failure occurs."
                },
                "refresh_delay": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "For REST APIs, the delay between successive polls.",
                    "format": "regex"
                },
                "request_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "For REST APIs, the request timeout. If not set, a default value of 1s will be used.",
                    "format": "regex"
                },
                "rate_limit_settings": {
                    "$ref": "#/definitions/envoy.config.core.v3.RateLimitSettings",
                    "additionalProperties": true,
                    "description": "For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be rate limited."
                },
                "set_node_on_first_message_only": {
                    "type": "boolean",
                    "description": "Skip the node identifier in subsequent discovery requests for streaming gRPC config types."
                },
                "config_validators": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig"
                    },
                    "type": "array",
                    "description": "A list of config validators that will be executed when a new update is received from the ApiConfigSource. Note that each validator handles a specific xDS service type, and only the validators corresponding to the type url (in ``:ref: DiscoveryResponse`` or ``:ref: DeltaDiscoveryResponse``) will be invoked. If the validator returns false or throws an exception, the config will be rejected by the client, and a NACK will be sent. [#extension-category: envoy.config.validators]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Api Config Source",
            "description": "API configuration source. This identifies the API type and cluster that Envoy will use to fetch an xDS API. [#next-free-field: 10]"
        },
        "envoy.config.core.v3.BackoffStrategy": {
            "properties": {
                "base_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The base interval to be used for the next back off computation. It should be greater than zero and less than or equal to :ref:`max_interval \u003cenvoy_v3_api_field_config.core.v3.BackoffStrategy.max_interval\u003e`.",
                    "format": "regex"
                },
                "max_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the maximum interval between retries. This parameter is optional, but must be greater than or equal to the :ref:`base_interval \u003cenvoy_v3_api_field_config.core.v3.BackoffStrategy.base_interval\u003e` if set. The default is 10 times the :ref:`base_interval \u003cenvoy_v3_api_field_config.core.v3.BackoffStrategy.base_interval\u003e`.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Backoff strategy]",
            "description": "[#protodoc-title: Backoff strategy]  Configuration defining a jittered exponential back off strategy."
        },
        "envoy.config.core.v3.CidrRange": {
            "properties": {
                "address_prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``."
                },
                "prefix_len": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Length of prefix, e.g. 0, 32. Defaults to 0 when unset."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Cidr Range",
            "description": "CidrRange specifies an IP Address and a prefix length to construct the subnet mask for a `CIDR \u003chttps://tools.ietf.org/html/rfc4632\u003e`_ range."
        },
        "envoy.config.core.v3.ConfigSource": {
            "properties": {
                "authorities": {
                    "items": {
                        "$ref": "#/definitions/xds.core.v3.Authority"
                    },
                    "type": "array",
                    "description": "Authorities that this config source may be used for. An authority specified in a xdstp:// URL is resolved to a ``ConfigSource`` prior to configuration fetch. This field provides the association between authority name and configuration source. [#not-implemented-hide:]"
                },
                "path": {
                    "type": "string",
                    "description": "Deprecated in favor of ``path_config_source``. Use that field instead."
                },
                "path_config_source": {
                    "$ref": "#/definitions/envoy.config.core.v3.PathConfigSource",
                    "additionalProperties": true,
                    "description": "Local filesystem path configuration source."
                },
                "api_config_source": {
                    "$ref": "#/definitions/envoy.config.core.v3.ApiConfigSource",
                    "additionalProperties": true,
                    "description": "API configuration source."
                },
                "ads": {
                    "$ref": "#/definitions/envoy.config.core.v3.AggregatedConfigSource",
                    "additionalProperties": true,
                    "description": "When set, ADS will be used to fetch resources. The ADS API configuration source in the bootstrap configuration is used."
                },
                "self": {
                    "$ref": "#/definitions/envoy.config.core.v3.SelfConfigSource",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] When set, the client will access the resources from the same server it got the ConfigSource from, although not necessarily from the same stream. This is similar to the :ref:`ads\u003cenvoy_v3_api_field.ConfigSource.ads\u003e` field, except that the client may use a different stream to the same server. As a result, this field can be used for things like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.) LDS to RDS on the same server without requiring the management server to know its name or required credentials. [#next-major-version: In xDS v3, consider replacing the ads field with this one, since this field can implicitly mean to use the same stream in the case where the ConfigSource is provided via ADS and the specified data can also be obtained via ADS.]"
                },
                "initial_fetch_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "When this timeout is specified, Envoy will wait no longer than the specified time for first config response on this xDS subscription during the :ref:`initialization process \u003carch_overview_initialization\u003e`. After reaching the timeout, Envoy will move to the next initialization phase, even if the first config is not delivered yet. The timer is activated when the xDS API subscription starts, and is disarmed on first config update or on error. 0 means no timeout - Envoy will wait indefinitely for the first xDS config (unless another timeout applies). The default is 15s.",
                    "format": "regex"
                },
                "resource_api_version": {
                    "enum": [
                        "AUTO",
                        0,
                        "V2",
                        1,
                        "V3",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: Configuration sources]",
                    "description": "[#protodoc-title: Configuration sources]  xDS API and non-xDS services version. This is used to describe both resource and transport protocol versions (in distinct configuration fields)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Config Source",
            "description": "Configuration for :ref:`listeners \u003cconfig_listeners\u003e`, :ref:`clusters \u003cconfig_cluster_manager\u003e`, :ref:`routes \u003cenvoy_v3_api_msg_config.route.v3.RouteConfiguration\u003e`, :ref:`endpoints \u003carch_overview_service_discovery\u003e` etc. may either be sourced from the filesystem or from an xDS API source. Filesystem configs are watched with inotify for updates. [#next-free-field: 9]"
        },
        "envoy.config.core.v3.DataSource": {
            "properties": {
                "filename": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Local filesystem data source."
                },
                "inline_bytes": {
                    "type": "string",
                    "description": "Bytes inlined in the configuration.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "inline_string": {
                    "type": "string",
                    "description": "String inlined in the configuration."
                },
                "environment_variable": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Environment variable data source."
                },
                "watched_directory": {
                    "$ref": "#/definitions/envoy.config.core.v3.WatchedDirectory",
                    "additionalProperties": true,
                    "description": "Watched directory that is watched for file changes. If this is set explicitly, the file specified in the ``filename`` field will be reloaded when relevant file move events occur. .. note::   This field only makes sense when the ``filename`` field is set. .. note::   Envoy only updates when the file is replaced by a file move, and not when the file is   edited in place. .. note::   Not all use cases of ``DataSource`` support watching directories. It depends on the   specific usage of the ``DataSource``. See the documentation of the parent message for   details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Data Source",
            "description": "Data source consisting of a file, an inline value, or an environment variable. [#next-free-field: 6]"
        },
        "envoy.config.core.v3.EnvoyInternalAddress": {
            "properties": {
                "server_listener_name": {
                    "type": "string",
                    "description": "Specifies the :ref:`name \u003cenvoy_v3_api_field_config.listener.v3.Listener.name\u003e` of the internal listener."
                },
                "endpoint_id": {
                    "type": "string",
                    "description": "Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for example, may be set to the final destination IP for the target internal listener."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Envoy Internal Address",
            "description": "The address represents an envoy internal listener. [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]"
        },
        "envoy.config.core.v3.ExtensionConfigSource": {
            "properties": {
                "config_source": {
                    "$ref": "#/definitions/envoy.config.core.v3.ConfigSource",
                    "additionalProperties": true
                },
                "default_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Optional default configuration to use as the initial configuration if there is a failure to receive the initial extension configuration or if ``apply_default_config_without_warming`` flag is set."
                },
                "apply_default_config_without_warming": {
                    "type": "boolean",
                    "description": "Use the default config as the initial configuration without warming and waiting for the first discovery response. Requires the default configuration to be supplied."
                },
                "type_urls": {
                    "items": {
                        "type": "string"
                    },
                    "minItems": 1,
                    "type": "array",
                    "description": "A set of permitted extension type URLs. Extension configuration updates are rejected if they do not match any type URL in the set."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Extension Config Source",
            "description": "Configuration source specifier for a late-bound extension configuration. The parent resource is warmed until all the initial extension configurations are received, unless the flag to apply the default configuration is set. Subsequent extension updates are atomic on a per-worker basis. Once an extension configuration is applied to a request or a connection, it remains constant for the duration of processing. If the initial delivery of the extension configuration fails, due to a timeout for example, the optional default configuration is applied. Without a default configuration, the extension is disabled, until an extension configuration is received. The behavior of a disabled extension depends on the context. For example, a filter chain with a disabled extension filter rejects all incoming streams."
        },
        "envoy.config.core.v3.GrpcService": {
            "properties": {
                "envoy_grpc": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.EnvoyGrpc",
                    "additionalProperties": true,
                    "description": "Envoy's in-built gRPC client. See the :ref:`gRPC services overview \u003carch_overview_grpc_services\u003e` documentation for discussion on gRPC client selection."
                },
                "google_grpc": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc",
                    "additionalProperties": true,
                    "description": "`Google C++ gRPC client \u003chttps://github.com/grpc/grpc\u003e`_ See the :ref:`gRPC services overview \u003carch_overview_grpc_services\u003e` documentation for discussion on gRPC client selection."
                },
                "timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The timeout for the gRPC request. This is the timeout for a specific request.",
                    "format": "regex"
                },
                "initial_metadata": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HeaderValue"
                    },
                    "type": "array",
                    "description": "Additional metadata to include in streams initiated to the GrpcService. This can be used for scenarios in which additional ad hoc authorization headers (e.g. ``x-foo-bar: baz-key``) are to be injected. For more information, including details on header value syntax, see the documentation on :ref:`custom request headers \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                },
                "retry_policy": {
                    "$ref": "#/definitions/envoy.config.core.v3.RetryPolicy",
                    "additionalProperties": true,
                    "description": "Optional default retry policy for streams toward the service. If an async stream doesn't have retry policy configured in its stream options, this retry policy is used."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: gRPC services]",
            "description": "[#protodoc-title: gRPC services]  gRPC service configuration. This is used by :ref:`ApiConfigSource \u003cenvoy_v3_api_msg_config.core.v3.ApiConfigSource\u003e` and filter configurations. [#next-free-field: 7]"
        },
        "envoy.config.core.v3.GrpcService.EnvoyGrpc": {
            "properties": {
                "cluster_name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the upstream gRPC cluster. SSL credentials will be supplied in the :ref:`Cluster \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e` :ref:`transport_socket \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.transport_socket\u003e`."
                },
                "authority": {
                    "type": "string",
                    "description": "The ``:authority`` header in the grpc request. If this field is not set, the authority header value will be ``cluster_name``. Note that this authority does not override the SNI. The SNI is provided by the transport socket of the cluster."
                },
                "retry_policy": {
                    "$ref": "#/definitions/envoy.config.core.v3.RetryPolicy",
                    "additionalProperties": true,
                    "description": "Indicates the retry policy for re-establishing the gRPC stream This field is optional. If max interval is not provided, it will be set to ten times the provided base interval. Currently only supported for xDS gRPC streams. If not set, xDS gRPC streams default base interval:500ms, maximum interval:30s will be applied."
                },
                "max_receive_message_length": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Maximum gRPC message size that is allowed to be received. If a message over this limit is received, the gRPC stream is terminated with the RESOURCE_EXHAUSTED error. This limit is applied to individual messages in the streaming response and not the total size of streaming response. Defaults to 0, which means unlimited."
                },
                "skip_envoy_headers": {
                    "type": "boolean",
                    "description": "This provides gRPC client level control over envoy generated headers. If false, the header will be sent but it can be overridden by per stream option. If true, the header will be removed and can not be overridden by per stream option. Default to false."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Envoy Grpc",
            "description": "[#next-free-field: 6]"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc": {
            "properties": {
                "target_uri": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The target URI when using the `Google C++ gRPC client \u003chttps://github.com/grpc/grpc\u003e`_. SSL credentials will be supplied in :ref:`channel_credentials \u003cenvoy_v3_api_field_config.core.v3.GrpcService.GoogleGrpc.channel_credentials\u003e`."
                },
                "channel_credentials": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelCredentials",
                    "additionalProperties": true
                },
                "call_credentials": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials"
                    },
                    "type": "array",
                    "description": "A set of call credentials that can be composed with `channel credentials \u003chttps://grpc.io/docs/guides/auth.html#credential-types\u003e`_."
                },
                "stat_prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The human readable prefix to use when emitting statistics for the gRPC service. .. csv-table::    :header: Name, Type, Description    :widths: 1, 1, 2    streams_total, Counter, Total number of streams opened    streams_closed_\u003cgRPC status code\u003e, Counter, Total streams closed with \u003cgRPC status code\u003e"
                },
                "credentials_factory_name": {
                    "type": "string",
                    "description": "The name of the Google gRPC credentials factory to use. This must have been registered with Envoy. If this is empty, a default credentials factory will be used that sets up channel credentials based on other configuration parameters."
                },
                "config": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Additional configuration for site-specific customizations of the Google gRPC library."
                },
                "per_stream_buffer_limit_bytes": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "How many bytes each stream can buffer internally. If not set an implementation defined default is applied (1MiB)."
                },
                "channel_args": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelArgs",
                    "additionalProperties": true,
                    "description": "Custom channels args."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Google Grpc",
            "description": "[#next-free-field: 9]"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials": {
            "properties": {
                "access_token": {
                    "type": "string",
                    "description": "Access token credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#ad3a80da696ffdaea943f0f858d7a360d."
                },
                "google_compute_engine": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Google Compute Engine credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61"
                },
                "google_refresh_token": {
                    "type": "string",
                    "description": "Google refresh token credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a96901c997b91bc6513b08491e0dca37c."
                },
                "service_account_jwt_access": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials",
                    "additionalProperties": true,
                    "description": "Service Account JWT Access credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a92a9f959d6102461f66ee973d8e9d3aa."
                },
                "google_iam": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials",
                    "additionalProperties": true,
                    "description": "Google IAM credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a9fc1fc101b41e680d47028166e76f9d0."
                },
                "from_plugin": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin",
                    "additionalProperties": true,
                    "description": "Custom authenticator credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a823c6a4b19ffc71fb33e90154ee2ad07. https://grpc.io/docs/guides/auth.html#extending-grpc-to-support-other-authentication-mechanisms."
                },
                "sts_service": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.StsService",
                    "additionalProperties": true,
                    "description": "Custom security token service which implements OAuth 2.0 token exchange. https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16 See https://github.com/grpc/grpc/pull/19587."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Call Credentials",
            "description": "[#next-free-field: 8]"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials": {
            "properties": {
                "authorization_token": {
                    "type": "string"
                },
                "authority_selector": {
                    "type": "string"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Google IAM Credentials"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata Credentials From Plugin"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials": {
            "properties": {
                "json_key": {
                    "type": "string"
                },
                "token_lifetime_seconds": {
                    "type": "string"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Service Account JWT Access Credentials"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.StsService": {
            "properties": {
                "token_exchange_service_uri": {
                    "type": "string",
                    "description": "URI of the token exchange service that handles token exchange requests. [#comment:TODO(asraa): Add URI validation when implemented. Tracked by https://github.com/bufbuild/protoc-gen-validate/issues/303]"
                },
                "resource": {
                    "type": "string",
                    "description": "Location of the target service or resource where the client intends to use the requested security token."
                },
                "audience": {
                    "type": "string",
                    "description": "Logical name of the target service where the client intends to use the requested security token."
                },
                "scope": {
                    "type": "string",
                    "description": "The desired scope of the requested security token in the context of the service or resource where the token will be used."
                },
                "requested_token_type": {
                    "type": "string",
                    "description": "Type of the requested security token."
                },
                "subject_token_path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The path of subject token, a security token that represents the identity of the party on behalf of whom the request is being made."
                },
                "subject_token_type": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Type of the subject token."
                },
                "actor_token_path": {
                    "type": "string",
                    "description": "The path of actor token, a security token that represents the identity of the acting party. The acting party is authorized to use the requested security token and act on behalf of the subject."
                },
                "actor_token_type": {
                    "type": "string",
                    "description": "Type of the actor token."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Sts Service",
            "description": "Security token service configuration that allows Google gRPC to fetch security token from an OAuth 2.0 authorization server. See https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16 and https://github.com/grpc/grpc/pull/19587. [#next-free-field: 10]"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelArgs": {
            "properties": {
                "args": {
                    "additionalProperties": {
                        "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelArgs.Value",
                        "additionalProperties": true
                    },
                    "type": "object",
                    "description": "See grpc_types.h GRPC_ARG #defines for keys that work here."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Channel Args",
            "description": "Channel arguments."
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelArgs.Value": {
            "properties": {
                "string_value": {
                    "type": "string"
                },
                "int_value": {
                    "type": "string"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Value"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelCredentials": {
            "properties": {
                "ssl_credentials": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.SslCredentials",
                    "additionalProperties": true
                },
                "google_default": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61"
                },
                "local_credentials": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.GoogleLocalCredentials",
                    "additionalProperties": true
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Channel Credentials",
            "description": "See https://grpc.io/docs/guides/auth.html#credential-types to understand Channel and Call credential types."
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.GoogleLocalCredentials": {
            "additionalProperties": true,
            "type": "object",
            "title": "Google Local Credentials",
            "description": "Local channel credentials. Only UDS is supported for now. See https://github.com/grpc/grpc/pull/15909."
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.SslCredentials": {
            "properties": {
                "root_certs": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "PEM encoded server root certificates."
                },
                "private_key": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "PEM encoded client private key."
                },
                "cert_chain": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "PEM encoded client certificate chain."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Ssl Credentials",
            "description": "See https://grpc.io/grpc/cpp/structgrpc_1_1_ssl_credentials_options.html."
        },
        "envoy.config.core.v3.HeaderValue": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Header name."
                },
                "value": {
                    "type": "string",
                    "description": "Header value. The same :ref:`format specifier \u003cconfig_access_log_format\u003e` as used for :ref:`HTTP access logging \u003cconfig_access_log\u003e` applies here, however unknown header values are replaced with the empty string instead of ``-``. Header value is encoded as string. This does not work for non-utf8 characters. Only one of ``value`` or ``raw_value`` can be set."
                },
                "raw_value": {
                    "type": "string",
                    "description": "Header value is encoded as bytes which can support non-utf8 characters. Only one of ``value`` or ``raw_value`` can be set.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Value",
            "description": "Header name/value pair."
        },
        "envoy.config.core.v3.Metadata": {
            "properties": {
                "filter_metadata": {
                    "additionalProperties": {
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*`` namespace is reserved for Envoy's built-in filters. If both ``filter_metadata`` and :ref:`typed_filter_metadata \u003cenvoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata\u003e` fields are present in the metadata with same keys, only ``typed_filter_metadata`` field will be parsed."
                },
                "typed_filter_metadata": {
                    "additionalProperties": {
                        "properties": {
                            "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                            },
                            "value": {
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "binary",
                                "binaryEncoding": "base64"
                            }
                        },
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*`` namespace is reserved for Envoy's built-in filters. The value is encoded as google.protobuf.Any. If both :ref:`filter_metadata \u003cenvoy_v3_api_field_config.core.v3.Metadata.filter_metadata\u003e` and ``typed_filter_metadata`` fields are present in the metadata with same keys, only ``typed_filter_metadata`` field will be parsed."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Metadata provides additional inputs to filters based on matched listeners, filter chains, routes and endpoints. It is structured as a map, usually from filter name (in reverse DNS format) to metadata specific to the filter. Metadata key-values for a filter are merged as connection and request handling occurs, with later values for the same key overriding earlier values. An example use of metadata is providing additional values to http_connection_manager in the envoy.http_connection_manager.access_log namespace. Another example use of metadata is to per service config info in cluster metadata, which may get consumed by multiple filters. For load balancing, Metadata provides a means to subset cluster endpoints. Endpoints have a Metadata object associated and routes contain a Metadata object to match against. There are some well defined metadata used today for this purpose: * ``{\"envoy.lb\": {\"canary\": \u003cbool\u003e }}`` This indicates the canary status of an   endpoint and is also used during header processing   (x-envoy-upstream-canary) and for stats purposes. [#next-major-version: move to type/metadata/v2]"
        },
        "envoy.config.core.v3.PathConfigSource": {
            "properties": {
                "path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Path on the filesystem to source and watch for configuration updates. When sourcing configuration for a :ref:`secret \u003cenvoy_v3_api_msg_extensions.transport_sockets.tls.v3.Secret\u003e`, the certificate and key files are also watched for updates. .. note::  The path to the source must exist at config load time. .. note::   If ``watched_directory`` is *not* configured, Envoy will watch the file path for *moves*.   This is because in general only moves are atomic. The same method of swapping files as is   demonstrated in the :ref:`runtime documentation \u003cconfig_runtime_symbolic_link_swap\u003e` can be   used here also. If ``watched_directory`` is configured, no watch will be placed directly on   this path. Instead, the configured ``watched_directory`` will be used to trigger reloads of   this path. This is required in certain deployment scenarios. See below for more information."
                },
                "watched_directory": {
                    "$ref": "#/definitions/envoy.config.core.v3.WatchedDirectory",
                    "additionalProperties": true,
                    "description": "If configured, this directory will be watched for *moves*. When an entry in this directory is moved to, the ``path`` will be reloaded. This is required in certain deployment scenarios. Specifically, if trying to load an xDS resource using a `Kubernetes ConfigMap \u003chttps://kubernetes.io/docs/concepts/configuration/configmap/\u003e`_, the following configuration might be used: 1. Store xds.yaml inside a ConfigMap. 2. Mount the ConfigMap to ``/config_map/xds`` 3. Configure path ``/config_map/xds/xds.yaml`` 4. Configure watched directory ``/config_map/xds`` The above configuration will ensure that Envoy watches the owning directory for moves which is required due to how Kubernetes manages ConfigMap symbolic links during atomic updates."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Path Config Source",
            "description": "Local filesystem path configuration source."
        },
        "envoy.config.core.v3.Pipe": {
            "properties": {
                "path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Unix Domain Socket path. On Linux, paths starting with '@' will use the abstract namespace. The starting '@' is replaced by a null byte by Envoy. Paths starting with '@' will result in an error in environments other than Linux."
                },
                "mode": {
                    "type": "integer",
                    "description": "The mode for the Pipe. Not applicable for abstract sockets."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Network addresses]",
            "description": "[#protodoc-title: Network addresses]"
        },
        "envoy.config.core.v3.QuicKeepAliveSettings": {
            "properties": {
                "max_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout \u003cenvoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout\u003e` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes. If :ref:`initial_interval \u003cenvoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval\u003e` is absent or zero, a client connection will use this value to start probing. If zero, disable keepalive probing. If absent, use the QUICHE default interval to probe.",
                    "format": "regex"
                },
                "initial_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval \u003cenvoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval\u003e`. And the probes afterwards will always use :ref:`max_interval \u003cenvoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval\u003e`. The value should be smaller than :ref:`connection idle_timeout \u003cenvoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout\u003e` to prevent idle timeout and smaller than max_interval to take effect. If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval \u003cenvoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval\u003e`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Quic Keep Alive Settings",
            "description": "Config for keepalive probes in a QUIC connection. Note that QUIC keep-alive probing packets work differently from HTTP/2 keep-alive PINGs in a sense that the probing packet itself doesn't timeout waiting for a probing response. Quic has a shorter idle timeout than TCP, so it doesn't rely on such probing to discover dead connections. If the peer fails to respond, the connection will idle timeout eventually. Thus, they are configured differently from :ref:`connection_keepalive \u003cenvoy_v3_api_field_config.core.v3.Http2ProtocolOptions.connection_keepalive\u003e`."
        },
        "envoy.config.core.v3.QuicProtocolOptions": {
            "properties": {
                "max_concurrent_streams": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Maximum number of streams that the client can negotiate per connection. 100 if not specified."
                },
                "initial_stream_window_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "`Initial stream-level flow-control receive window \u003chttps://tools.ietf.org/html/draft-ietf-quic-transport-34#section-4.1\u003e`_ size. Valid values range from 1 to 16777216 (2^24, maximum supported by QUICHE) and defaults to 16777216 (16 * 1024 * 1024). NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. If configured smaller than it, we will use 16384 instead. QUICHE IETF Quic implementation supports 1 bytes window. We only support increasing the default window size now, so it's also the minimum. This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the QUIC stream send and receive buffers. Once the buffer reaches this pointer, watermark callbacks will fire to stop the flow of data to the stream buffers."
                },
                "initial_connection_window_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Similar to ``initial_stream_window_size``, but for connection-level flow-control. Valid values rage from 1 to 25165824 (24MB, maximum supported by QUICHE) and defaults to 25165824 (24 * 1024 * 1024). NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. We only support increasing the default window size now, so it's also the minimum."
                },
                "num_timeouts_to_trigger_port_migration": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of timeouts that can occur before port migration is triggered for QUIC clients. This defaults to 4. If set to 0, port migration will not occur on path degrading. Timeout here refers to QUIC internal path degrading timeout mechanism, such as PTO. This has no effect on server sessions."
                },
                "connection_keepalive": {
                    "$ref": "#/definitions/envoy.config.core.v3.QuicKeepAliveSettings",
                    "additionalProperties": true,
                    "description": "Probes the peer at the configured interval to solicit traffic, i.e. ACK or PATH_RESPONSE, from the peer to push back connection idle timeout. If absent, use the default keepalive behavior of which a client connection sends PINGs every 15s, and a server connection doesn't do anything."
                },
                "connection_options": {
                    "type": "string",
                    "description": "A comma-separated list of strings representing QUIC connection options defined in `QUICHE \u003chttps://github.com/google/quiche/blob/main/quiche/quic/core/crypto/crypto_protocol.h\u003e`_ and to be sent by upstream connections."
                },
                "client_connection_options": {
                    "type": "string",
                    "description": "A comma-separated list of strings representing QUIC client connection options defined in `QUICHE \u003chttps://github.com/google/quiche/blob/main/quiche/quic/core/crypto/crypto_protocol.h\u003e`_ and to be sent by upstream connections."
                },
                "idle_network_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The duration that a QUIC connection stays idle before it closes itself. If this field is not present, QUICHE default 600s will be applied. For internal corporate network, a long timeout is often fine. But for client facing network, 30s is usually a good choice.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Quic Protocol Options",
            "description": "QUIC protocol options which apply to both downstream and upstream connections. [#next-free-field: 9]"
        },
        "envoy.config.core.v3.RateLimitSettings": {
            "properties": {
                "max_tokens": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a default value of 100 will be used."
                },
                "fill_rate": {
                    "additionalProperties": true,
                    "type": "number",
                    "description": "Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens per second will be used. The minimal fill rate is once per year. Lower fill rates will be set to once per year."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Rate Limit Settings",
            "description": "Rate Limit settings to be applied for discovery requests made by Envoy."
        },
        "envoy.config.core.v3.RetryPolicy": {
            "properties": {
                "retry_back_off": {
                    "$ref": "#/definitions/envoy.config.core.v3.BackoffStrategy",
                    "additionalProperties": true,
                    "description": "Specifies parameters that control :ref:`retry backoff strategy \u003cenvoy_v3_api_msg_config.core.v3.BackoffStrategy\u003e`. This parameter is optional, in which case the default base interval is 1000 milliseconds. The default maximum interval is 10 times the base interval."
                },
                "num_retries": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specifies the allowed number of retries. This parameter is optional and defaults to 1."
                },
                "retry_on": {
                    "type": "string",
                    "description": "For details, see :ref:`retry_on \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_on\u003e`."
                },
                "retry_priority": {
                    "$ref": "#/definitions/envoy.config.core.v3.RetryPolicy.RetryPriority",
                    "additionalProperties": true,
                    "description": "For details, see :ref:`retry_priority \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_priority\u003e`."
                },
                "retry_host_predicate": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.RetryPolicy.RetryHostPredicate"
                    },
                    "type": "array",
                    "description": "For details, see :ref:`RetryHostPredicate \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_host_predicate\u003e`."
                },
                "host_selection_retry_max_attempts": {
                    "type": "string",
                    "description": "For details, see :ref:`host_selection_retry_max_attempts \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.host_selection_retry_max_attempts\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Policy",
            "description": "The message specifies the retry policy of remote data source when fetching fails. [#next-free-field: 7]"
        },
        "envoy.config.core.v3.RetryPolicy.RetryHostPredicate": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string"
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Host Predicate",
            "description": "See :ref:`RetryHostPredicate \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_host_predicate\u003e`."
        },
        "envoy.config.core.v3.RetryPolicy.RetryPriority": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string"
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Priority",
            "description": "See :ref:`RetryPriority \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_priority\u003e`."
        },
        "envoy.config.core.v3.RuntimeFeatureFlag": {
            "properties": {
                "default_value": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Default value if runtime value is not available."
                },
                "runtime_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Runtime key to get value for comparison. This value is used if defined. The boolean value must be represented via its `canonical JSON encoding \u003chttps://developers.google.com/protocol-buffers/docs/proto3#json\u003e`_."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime Feature Flag",
            "description": "Runtime derived bool with a default when not specified."
        },
        "envoy.config.core.v3.RuntimeUInt32": {
            "properties": {
                "default_value": {
                    "type": "integer",
                    "description": "Default value if runtime value is not available."
                },
                "runtime_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Runtime key to get value for comparison. This value is used if defined."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime U Int 32",
            "description": "Runtime derived uint32 with a default when not specified."
        },
        "envoy.config.core.v3.SelfConfigSource": {
            "properties": {
                "transport_api_version": {
                    "enum": [
                        "AUTO",
                        0,
                        "V2",
                        1,
                        "V3",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: Configuration sources]",
                    "description": "[#protodoc-title: Configuration sources]  xDS API and non-xDS services version. This is used to describe both resource and transport protocol versions (in distinct configuration fields)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Self Config Source",
            "description": "[#not-implemented-hide:] Self-referencing config source options. This is currently empty, but when set in :ref:`ConfigSource \u003cenvoy_v3_api_msg_config.core.v3.ConfigSource\u003e` can be used to specify that other data can be obtained from the same server."
        },
        "envoy.config.core.v3.SocketAddress": {
            "properties": {
                "protocol": {
                    "enum": [
                        "TCP",
                        0,
                        "UDP",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Protocol"
                },
                "address": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The address for this socket. :ref:`Listeners \u003cconfig_listeners\u003e` will bind to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::`` to bind to any address. [#comment:TODO(zuercher) reinstate when implemented: It is possible to distinguish a Listener address via the prefix/suffix matching in :ref:`FilterChainMatch \u003cenvoy_v3_api_msg_config.listener.v3.FilterChainMatch\u003e`.] When used within an upstream :ref:`BindConfig \u003cenvoy_v3_api_msg_config.core.v3.BindConfig\u003e`, the address controls the source address of outbound connections. For :ref:`clusters \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e`, the cluster type determines whether the address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized via :ref:`resolver_name \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.resolver_name\u003e`."
                },
                "port_value": {
                    "type": "integer"
                },
                "named_port": {
                    "type": "string",
                    "description": "This is only valid if :ref:`resolver_name \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.resolver_name\u003e` is specified below and the named resolver is capable of named port resolution."
                },
                "resolver_name": {
                    "type": "string",
                    "description": "The name of the custom resolver. This must have been registered with Envoy. If this is empty, a context dependent default applies. If the address is a concrete IP address, no resolution will occur. If address is a hostname this should be set for resolution other than DNS. Specifying a custom resolver with ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime."
                },
                "ipv4_compat": {
                    "type": "boolean",
                    "description": "When binding to an IPv6 address above, this enables `IPv4 compatibility \u003chttps://tools.ietf.org/html/rfc3493#page-11\u003e`_. Binding to ``::`` will allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into IPv6 space as ``::FFFF:\u003cIPv4-address\u003e``."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Socket Address",
            "description": "[#next-free-field: 7]"
        },
        "envoy.config.core.v3.SocketOption": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional name to give this socket option for debugging, etc. Uniqueness is not required and no special meaning is assumed."
                },
                "level": {
                    "type": "string",
                    "description": "Corresponding to the level value passed to setsockopt, such as IPPROTO_TCP"
                },
                "name": {
                    "type": "string",
                    "description": "The numeric name as passed to setsockopt"
                },
                "int_value": {
                    "type": "string",
                    "description": "Because many sockopts take an int value."
                },
                "buf_value": {
                    "type": "string",
                    "description": "Otherwise it's a byte buffer.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "state": {
                    "enum": [
                        "STATE_PREBIND",
                        0,
                        "STATE_BOUND",
                        1,
                        "STATE_LISTENING",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Socket State"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Socket option]",
            "description": "[#protodoc-title: Socket option]  Generic socket option message. This would be used to set socket options that might not exist in upstream kernels or precompiled Envoy binaries. For example: .. code-block:: json  {    \"description\": \"support tcp keep alive\",    \"state\": 0,    \"level\": 1,    \"name\": 9,    \"int_value\": 1,  } 1 means SOL_SOCKET and 9 means SO_KEEPALIVE on Linux. With the above configuration, `TCP Keep-Alives \u003chttps://www.freesoft.org/CIE/RFC/1122/114.htm\u003e`_ can be enabled in socket with Linux, which can be used in :ref:`listener's\u003cenvoy_v3_api_field_config.listener.v3.Listener.socket_options\u003e` or :ref:`admin's \u003cenvoy_v3_api_field_config.bootstrap.v3.Admin.socket_options\u003e` socket_options etc. It should be noted that the name or level may have different values on different platforms. [#next-free-field: 7]"
        },
        "envoy.config.core.v3.SocketOptionsOverride": {
            "properties": {
                "socket_options": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.SocketOption"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Socket Options Override"
        },
        "envoy.config.core.v3.TransportSocket": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the transport socket to instantiate. The name must match a supported transport socket implementation."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Transport Socket",
            "description": "Configuration for transport socket in :ref:`listeners \u003cconfig_listeners\u003e` and :ref:`clusters \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e`. If the configuration is empty, a default transport socket implementation and configuration will be chosen based on the platform and existence of tls_context."
        },
        "envoy.config.core.v3.TypedExtensionConfig": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of an extension. This is not used to select the extension, instead it serves the role of an opaque identifier."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The typed config for the extension. The type URL will be used to identify the extension. In the case that the type URL is ``xds.type.v3.TypedStruct`` (or, for historical reasons, ``udpa.type.v1.TypedStruct``), the inner type URL of ``TypedStruct`` will be utilized. See the :ref:`extension configuration overview \u003cconfig_overview_extension_configuration\u003e` for further details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Extension configuration]",
            "description": "[#protodoc-title: Extension configuration]  Message type for extension configuration. [#next-major-version: revisit all existing typed_config that doesn't use this wrapper.]."
        },
        "envoy.config.core.v3.UdpSocketConfig": {
            "properties": {
                "max_rx_datagram_size": {
                    "additionalProperties": true,
                    "type": "string",
                    "description": "The maximum size of received UDP datagrams. Using a larger size will cause Envoy to allocate more memory per socket. Received datagrams above this size will be dropped. If not set defaults to 1500 bytes."
                },
                "prefer_gro": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Configures whether Generic Receive Offload (GRO) \u003chttps://en.wikipedia.org/wiki/Large_receive_offload\u003e_ is preferred when reading from the UDP socket. The default is context dependent and is documented where UdpSocketConfig is used. This option affects performance but not functionality. If GRO is not supported by the operating system, non-GRO receive will be used."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: UDP socket config]",
            "description": "[#protodoc-title: UDP socket config]  Generic UDP socket configuration."
        },
        "envoy.config.core.v3.WatchedDirectory": {
            "properties": {
                "path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Directory path to watch."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Watched Directory",
            "description": "A directory that is watched for changes, e.g. by inotify on Linux. Move/rename events inside this directory trigger the watch."
        },
        "envoy.config.listener.v3.AdditionalAddress": {
            "properties": {
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.Address",
                    "additionalProperties": true
                },
                "socket_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.SocketOptionsOverride",
                    "additionalProperties": true,
                    "description": "Additional socket options that may not be present in Envoy source code or precompiled binaries. If specified, this will override the :ref:`socket_options \u003cenvoy_v3_api_field_config.listener.v3.Listener.socket_options\u003e` in the listener. If specified with no :ref:`socket_options \u003cenvoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options\u003e` or an empty list of :ref:`socket_options \u003cenvoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options\u003e`, it means no socket option will apply."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Listener configuration]\n Listener :ref:`configuration overview \u003cconfig_listeners\u003e`",
            "description": "[#protodoc-title: Listener configuration] Listener :ref:`configuration overview \u003cconfig_listeners\u003e`  The additional address the listener is listening on."
        },
        "envoy.config.listener.v3.ApiListener": {
            "properties": {
                "api_listener": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The type in this field determines the type of API listener. At present, the following types are supported: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager (HTTP) envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager (HTTP) [#next-major-version: In the v3 API, replace this Any field with a oneof containing the specific config message for each type of API listener. We could not do this in v2 because it would have caused circular dependencies for go protos: lds.proto depends on this file, and http_connection_manager.proto depends on rds.proto, which is in the same directory as lds.proto, so lds.proto cannot depend on this file.]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: API listener]",
            "description": "[#protodoc-title: API listener]  Describes a type of API listener, which is used in non-proxy clients. The type of API exposed to the non-proxy application depends on the type of API listener."
        },
        "envoy.config.listener.v3.Filter": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the filter configuration."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Filter specific configuration which depends on the filter being instantiated. See the supported filters for further documentation. [#extension-category: envoy.filters.network]"
                },
                "config_discovery": {
                    "$ref": "#/definitions/envoy.config.core.v3.ExtensionConfigSource",
                    "additionalProperties": true,
                    "description": "Configuration source specifier for an extension configuration discovery service. In case of a failure and without the default configuration, the listener closes the connections."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Listener components]\n Listener :ref:`configuration overview \u003cconfig_listeners\u003e`",
            "description": "[#protodoc-title: Listener components] Listener :ref:`configuration overview \u003cconfig_listeners\u003e`  [#next-free-field: 6]"
        },
        "envoy.config.listener.v3.FilterChain": {
            "properties": {
                "filter_chain_match": {
                    "$ref": "#/definitions/envoy.config.listener.v3.FilterChainMatch",
                    "additionalProperties": true,
                    "description": "The criteria to use when matching a connection to this filter chain."
                },
                "filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.Filter"
                    },
                    "type": "array",
                    "description": "A list of individual network filters that make up the filter chain for connections established with the listener. Order matters as the filters are processed sequentially as connection events happen. Note: If the filter list is empty, the connection will close by default. For QUIC listeners, network filters other than HTTP Connection Manager (HCM) can be created, but due to differences in the connection implementation compared to TCP, the onData() method will never be called. Therefore, network filters for QUIC listeners should only expect to do work at the start of a new connection (i.e. in onNewConnection()). HCM must be the last (or only) filter in the chain."
                },
                "use_proxy_proto": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should expect a PROXY protocol V1 header on new connections. If this option is enabled, the listener will assume that that remote address of the connection is the one specified in the header. Some load balancers including the AWS ELB support this option. If the option is absent or set to false, Envoy will use the physical peer address of the connection as the remote address. This field is deprecated. Add a :ref:`PROXY protocol listener filter \u003cconfig_listener_filters_proxy_protocol\u003e` explicitly instead."
                },
                "metadata": {
                    "$ref": "#/definitions/envoy.config.core.v3.Metadata",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] filter chain metadata."
                },
                "transport_socket": {
                    "$ref": "#/definitions/envoy.config.core.v3.TransportSocket",
                    "additionalProperties": true,
                    "description": "Optional custom transport socket implementation to use for downstream connections. To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and :ref:`DownstreamTlsContext \u003cenvoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext\u003e` in the ``typed_config``. If no transport socket configuration is specified, new connections will be set up with plaintext. [#extension-category: envoy.transport_sockets.downstream]"
                },
                "transport_socket_connect_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If present and nonzero, the amount of time to allow incoming connections to complete any transport socket negotiations. If this expires before the transport reports connection establishment, the connection is summarily closed.",
                    "format": "regex"
                },
                "name": {
                    "type": "string",
                    "description": "The unique name (or empty) by which this filter chain is known. Note: :ref:`filter_chain_matcher \u003cenvoy_v3_api_field_config.listener.v3.Listener.filter_chain_matcher\u003e` requires that filter chains are uniquely named within a listener."
                },
                "on_demand_configuration": {
                    "$ref": "#/definitions/envoy.config.listener.v3.FilterChain.OnDemandConfiguration",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] The configuration to specify whether the filter chain will be built on-demand. If this field is not empty, the filter chain will be built on-demand. Otherwise, the filter chain will be built normally and block listener warming."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Filter Chain",
            "description": "A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and various other parameters. [#next-free-field: 10]"
        },
        "envoy.config.listener.v3.FilterChain.OnDemandConfiguration": {
            "properties": {
                "rebuild_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The timeout to wait for filter chain placeholders to complete rebuilding. 1. If this field is set to 0, timeout is disabled. 2. If not specified, a default timeout of 15s is used. Rebuilding will wait until dependencies are ready, have failed, or this timeout is reached. Upon failure or timeout, all connections related to this filter chain will be closed. Rebuilding will start again on the next new connection.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "On Demand Configuration",
            "description": "The configuration for on-demand filter chain. If this field is not empty in FilterChain message, a filter chain will be built on-demand. On-demand filter chains help speedup the warming up of listeners since the building and initialization of an on-demand filter chain will be postponed to the arrival of new connection requests that require this filter chain. Filter chains that are not often used can be set as on-demand."
        },
        "envoy.config.listener.v3.FilterChainMatch": {
            "properties": {
                "destination_port": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Optional destination port to consider when use_original_dst is set on the listener in determining a filter chain match."
                },
                "prefix_ranges": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.CidrRange"
                    },
                    "type": "array",
                    "description": "If non-empty, an IP address and prefix length to match addresses when the listener is bound to 0.0.0.0/:: or when use_original_dst is specified."
                },
                "address_suffix": {
                    "type": "string",
                    "description": "If non-empty, an IP address and suffix length to match addresses when the listener is bound to 0.0.0.0/:: or when use_original_dst is specified. [#not-implemented-hide:]"
                },
                "suffix_len": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "[#not-implemented-hide:]"
                },
                "direct_source_prefix_ranges": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.CidrRange"
                    },
                    "type": "array",
                    "description": "The criteria is satisfied if the directly connected source IP address of the downstream connection is contained in at least one of the specified subnets. If the parameter is not specified or the list is empty, the directly connected source IP address is ignored."
                },
                "source_type": {
                    "enum": [
                        "ANY",
                        0,
                        "SAME_IP_OR_LOOPBACK",
                        1,
                        "EXTERNAL",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Connection Source Type"
                },
                "source_prefix_ranges": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.CidrRange"
                    },
                    "type": "array",
                    "description": "The criteria is satisfied if the source IP address of the downstream connection is contained in at least one of the specified subnets. If the parameter is not specified or the list is empty, the source IP address is ignored."
                },
                "source_ports": {
                    "items": {
                        "type": "integer"
                    },
                    "type": "array",
                    "description": "The criteria is satisfied if the source port of the downstream connection is contained in at least one of the specified ports. If the parameter is not specified, the source port is ignored."
                },
                "server_names": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining a filter chain match. Those values will be compared against the server names of a new connection, when detected by one of the listener filters. The server name will be matched against all wildcard domains, i.e. ``www.example.com`` will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``. Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid. The value ``*`` is also not supported, and ``server_names`` should be omitted instead. .. attention::   See the :ref:`FAQ entry \u003cfaq_how_to_setup_sni\u003e` on how to configure SNI for more   information."
                },
                "transport_protocol": {
                    "type": "string",
                    "description": "If non-empty, a transport protocol to consider when determining a filter chain match. This value will be compared against the transport protocol of a new connection, when it's detected by one of the listener filters. Suggested values include: * ``raw_buffer`` - default, used when no transport protocol is detected, * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector \u003cconfig_listener_filters_tls_inspector\u003e`   when TLS protocol is detected."
                },
                "application_protocols": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when determining a filter chain match. Those values will be compared against the application protocols of a new connection, when detected by one of the listener filters. Suggested values include: * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector   \u003cconfig_listener_filters_tls_inspector\u003e`, * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector \u003cconfig_listener_filters_tls_inspector\u003e` .. attention::   Currently, only :ref:`TLS Inspector \u003cconfig_listener_filters_tls_inspector\u003e` provides   application protocol detection based on the requested   `ALPN \u003chttps://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation\u003e`_ values.   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,   and matching on values other than ``h2`` is going to lead to a lot of false negatives,   unless all connecting clients are known to use ALPN."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Filter Chain Match",
            "description": "Specifies the match criteria for selecting a specific filter chain for a listener. In order for a filter chain to be selected, *ALL* of its criteria must be fulfilled by the incoming connection, properties of which are set by the networking stack and/or listener filters. The following order applies: 1. Destination port. 2. Destination IP address. 3. Server name (e.g. SNI for TLS protocol), 4. Transport protocol. 5. Application protocols (e.g. ALPN for TLS protocol). 6. Directly connected source IP address (this will only be different from the source IP address    when using a listener filter that overrides the source address, such as the :ref:`Proxy Protocol    listener filter \u003cconfig_listener_filters_proxy_protocol\u003e`). 7. Source type (e.g. any, local or external network). 8. Source IP address. 9. Source port. For criteria that allow ranges or wildcards, the most specific value in any of the configured filter chains that matches the incoming connection is going to be used (e.g. for SNI ``www.example.com`` the most specific match would be ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter chain without ``server_names`` requirements). A different way to reason about the filter chain matches: Suppose there exists N filter chains. Prune the filter chain set using the above 8 steps. In each step, filter chains which most specifically matches the attributes continue to the next step. The listener guarantees at most 1 filter chain is left after all of the steps. Example: For destination port, filter chains specifying the destination port of incoming traffic are the most specific match. If none of the filter chains specifies the exact destination port, the filter chains which do not specify ports are the most specific match. Filter chains specifying the wrong port can never be the most specific match. [#comment: Implemented rules are kept in the preference order, with deprecated fields listed at the end, because that's how we want to list them in the docs. [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules] [#next-free-field: 14]"
        },
        "envoy.config.listener.v3.Listener.ConnectionBalanceConfig": {
            "properties": {
                "exact_balance": {
                    "$ref": "#/definitions/envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance",
                    "additionalProperties": true,
                    "description": "If specified, the listener will use the exact connection balancer."
                },
                "extend_balance": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid, Envoy will not attempt to balance active connections between worker threads. [#extension-category: envoy.network.connection_balance]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Connection Balance Config",
            "description": "Configuration for listener connection balancing."
        },
        "envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance": {
            "additionalProperties": true,
            "type": "object",
            "title": "Exact Balance",
            "description": "A connection balancer implementation that does exact balancing. This means that a lock is held during balancing so that connection counts are nearly exactly balanced between worker threads. This is \"nearly\" exact in the sense that a connection might close in parallel thus making the counts incorrect, but this should be rectified on the next accept. This balancer sacrifices accept throughput for accuracy and should be used when there are a small number of connections that rarely cycle (e.g., service mesh gRPC egress)."
        },
        "envoy.config.listener.v3.Listener.DeprecatedV1": {
            "properties": {
                "bind_to_port": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should bind to the port. A listener that doesn't bind can only receive connections redirected from other listeners that set use_original_dst parameter to true. Default is true. This is deprecated. Use :ref:`Listener.bind_to_port \u003cenvoy_v3_api_field_config.listener.v3.Listener.bind_to_port\u003e`"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Deprecated V 1",
            "description": "[#not-implemented-hide:]"
        },
        "envoy.config.listener.v3.Listener.InternalListenerConfig": {
            "additionalProperties": true,
            "type": "object",
            "title": "Internal Listener Config",
            "description": "Configuration for envoy internal listener. All the future internal listener features should be added here."
        },
        "envoy.config.listener.v3.ListenerFilter": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the filter configuration."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Filter specific configuration which depends on the filter being instantiated. See the supported filters for further documentation. [#extension-category: envoy.filters.listener,envoy.filters.udp_listener]"
                },
                "config_discovery": {
                    "$ref": "#/definitions/envoy.config.core.v3.ExtensionConfigSource",
                    "additionalProperties": true,
                    "description": "Configuration source specifier for an extension configuration discovery service. In case of a failure and without the default configuration, the listener closes the connections."
                },
                "filter_disabled": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate",
                    "additionalProperties": true,
                    "description": "Optional match predicate used to disable the filter. The filter is enabled when this field is empty. See :ref:`ListenerFilterChainMatchPredicate \u003cenvoy_v3_api_msg_config.listener.v3.ListenerFilterChainMatchPredicate\u003e` for further examples."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Listener Filter",
            "description": "[#next-free-field: 6]"
        },
        "envoy.config.listener.v3.ListenerFilterChainMatchPredicate": {
            "properties": {
                "or_match": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet",
                    "additionalProperties": true,
                    "description": "A set that describes a logical OR. If any member of the set matches, the match configuration matches."
                },
                "and_match": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet",
                    "additionalProperties": true,
                    "description": "A set that describes a logical AND. If all members of the set match, the match configuration matches."
                },
                "not_match": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate",
                    "additionalProperties": true,
                    "description": "A negation match. The match configuration will match if the negated match condition matches."
                },
                "any_match": {
                    "type": "boolean",
                    "description": "The match configuration will always match."
                },
                "destination_port_range": {
                    "$ref": "#/definitions/envoy.type.v3.Int32Range",
                    "additionalProperties": true,
                    "description": "Match destination port. Particularly, the match evaluation must use the recovered local port if the owning listener filter is after :ref:`an original_dst listener filter \u003cconfig_listener_filters_original_dst\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Listener Filter Chain Match Predicate",
            "description": "Listener filter chain match configuration. This is a recursive structure which allows complex nested match configurations to be built using various logical operators. Examples: * Matches if the destination port is 3306. .. code-block:: yaml  destination_port_range:   start: 3306   end: 3307 * Matches if the destination port is 3306 or 15000. .. code-block:: yaml  or_match:    rules:      - destination_port_range:          start: 3306          end: 3307      - destination_port_range:          start: 15000          end: 15001 [#next-free-field: 6]"
        },
        "envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet": {
            "properties": {
                "rules": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate"
                    },
                    "type": "array",
                    "description": "The list of rules that make up the set."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Match Set",
            "description": "A set of match configurations used for logical operations."
        },
        "envoy.config.listener.v3.QuicProtocolOptions": {
            "properties": {
                "quic_protocol_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.QuicProtocolOptions",
                    "additionalProperties": true
                },
                "idle_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Maximum number of milliseconds that connection will be alive when there is no network activity. If it is less than 1ms, Envoy will use 1ms. 300000ms if not specified.",
                    "format": "regex"
                },
                "crypto_handshake_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Connection timeout in milliseconds before the crypto handshake is finished. If it is less than 5000ms, Envoy will use 5000ms. 20000ms if not specified.",
                    "format": "regex"
                },
                "enabled": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeFeatureFlag",
                    "additionalProperties": true,
                    "description": "Runtime flag that controls whether the listener is enabled or not. If not specified, defaults to enabled."
                },
                "packets_to_read_to_connection_count_ratio": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "A multiplier to number of connections which is used to determine how many packets to read per event loop. A reasonable number should allow the listener to process enough payload but not starve TCP and other UDP sockets and also prevent long event loop duration. The default value is 32. This means if there are N QUIC connections, the total number of packets to read in each read event will be 32 * N. The actual number of packets to read in total by the UDP listener is also bound by 6000, regardless of this field or how many connections there are."
                },
                "crypto_stream_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configure which implementation of ``quic::QuicCryptoClientStreamBase`` to be used for this listener. If not specified the :ref:`QUICHE default one configured by \u003cenvoy_v3_api_msg_extensions.quic.crypto_stream.v3.CryptoServerStreamConfig\u003e` will be used. [#extension-category: envoy.quic.server.crypto_stream]"
                },
                "proof_source_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configure which implementation of ``quic::ProofSource`` to be used for this listener. If not specified the :ref:`default one configured by \u003cenvoy_v3_api_msg_extensions.quic.proof_source.v3.ProofSourceConfig\u003e` will be used. [#extension-category: envoy.quic.proof_source]"
                },
                "connection_id_generator_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Config which implementation of ``quic::ConnectionIdGeneratorInterface`` to be used for this listener. If not specified the :ref:`default one configured by \u003cenvoy_v3_api_msg_extensions.quic.connection_id_generator.v3.DeterministicConnectionIdGeneratorConfig\u003e` will be used. [#extension-category: envoy.quic.connection_id_generator]"
                },
                "server_preferred_address_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configure the server's preferred address to advertise so that client can migrate to it. See :ref:`example \u003cenvoy_v3_api_msg_extensions.quic.server_preferred_address.v3.FixedServerPreferredAddressConfig\u003e` which configures a pair of v4 and v6 preferred addresses. The current QUICHE implementation will advertise only one of the preferred IPv4 and IPv6 addresses based on the address family the client initially connects with. If not specified, Envoy will not advertise any server's preferred address. [#extension-category: envoy.quic.server_preferred_address]"
                },
                "send_disable_active_migration": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Configure the server to send transport parameter `disable_active_migration \u003chttps://www.rfc-editor.org/rfc/rfc9000#section-18.2-4.30.1\u003e`_. Defaults to false (do not send this transport parameter)."
                },
                "connection_debug_visitor_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configure which implementation of ``quic::QuicConnectionDebugVisitor`` to be used for this listener. If not specified, no debug visitor will be attached to connections. [#extension-category: envoy.quic.connection_debug_visitor]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: QUIC listener config]",
            "description": "[#protodoc-title: QUIC listener config]  Configuration specific to the UDP QUIC listener. [#next-free-field: 12]"
        },
        "envoy.config.listener.v3.UdpListenerConfig": {
            "properties": {
                "downstream_socket_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.UdpSocketConfig",
                    "additionalProperties": true,
                    "description": "UDP socket configuration for the listener. The default for :ref:`prefer_gro \u003cenvoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro\u003e` is false for listener sockets. If receiving a large amount of datagrams from a small number of sources, it may be worthwhile to enable this option after performance testing."
                },
                "quic_options": {
                    "$ref": "#/definitions/envoy.config.listener.v3.QuicProtocolOptions",
                    "additionalProperties": true,
                    "description": "Configuration for QUIC protocol. If empty, QUIC will not be enabled on this listener. Set to the default object to enable QUIC without modifying any additional options."
                },
                "udp_packet_packet_writer_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configuration for the UDP packet writer. If empty, HTTP/3 will use GSO if available (:ref:`UdpDefaultWriterFactory \u003cenvoy_v3_api_msg_extensions.udp_packet_writer.v3.UdpGsoBatchWriterFactory\u003e`) or the default kernel sendmsg if not, (:ref:`UdpDefaultWriterFactory \u003cenvoy_v3_api_msg_extensions.udp_packet_writer.v3.UdpDefaultWriterFactory\u003e`) and raw UDP will use kernel sendmsg. [#extension-category: envoy.udp_packet_writer]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: UDP listener config]\n Listener :ref:`configuration overview \u003cconfig_listeners\u003e`",
            "description": "[#protodoc-title: UDP listener config] Listener :ref:`configuration overview \u003cconfig_listeners\u003e`  [#next-free-field: 9]"
        },
        "envoy.config.route.v3.HeaderMatcher": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Specifies the name of the header in the request."
                },
                "exact_match": {
                    "type": "string",
                    "description": "If specified, header match will be performed based on the value of the header. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`."
                },
                "safe_regex_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`."
                },
                "range_match": {
                    "$ref": "#/definitions/envoy.type.v3.Int64Range",
                    "additionalProperties": true,
                    "description": "If specified, header match will be performed based on range. The rule will match if the request header value is within this range. The entire request header value must represent an integer in base 10 notation: consisting of an optional plus or minus sign followed by a sequence of digits. The rule will not match if the header value does not represent an integer. Match will fail for empty values, floating point numbers or if only a subsequence of the header value is an integer. Examples: * For range [-10,0), route will match for header value -1, but not for 0, ``somestring``, 10.9,   ``-1somestring``"
                },
                "present_match": {
                    "type": "boolean",
                    "description": "If specified as true, header match will be performed based on whether the header is in the request. If specified as false, header match will be performed based on whether the header is absent."
                },
                "prefix_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on the prefix of the header value. Note: empty prefix is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The prefix ``abcd`` matches the value ``abcdxyz``, but not for ``abcxyz``."
                },
                "suffix_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on the suffix of the header value. Note: empty suffix is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The suffix ``abcd`` matches the value ``xyzabcd``, but not for ``xyzbcd``."
                },
                "contains_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on whether the header value contains the given value or not. Note: empty contains match is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The value ``abcd`` matches the value ``xyzabcdpqr``, but not for ``xyzbcdpqr``."
                },
                "string_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "If specified, header match will be performed based on the string match of the header value."
                },
                "invert_match": {
                    "type": "boolean",
                    "description": "If specified, the match result will be inverted before checking. Defaults to false. Examples: * The regex ``\\d{3}`` does not match the value ``1234``, so it will match when inverted. * The range [-10,0) will match the value -1, so it will not match when inverted."
                },
                "treat_missing_header_as_empty": {
                    "type": "boolean",
                    "description": "If specified, for any header match rule, if the header match rule specified header does not exist, this header value will be treated as empty. Defaults to false. Examples: * The header match rule specified header \"header1\" to range match of [0, 10],   :ref:`invert_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match\u003e`   is set to true and :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to true; The \"header1\" header is not present. The match rule will   treat the \"header1\" as an empty header. The empty header does not match the range,   so it will match when inverted. * The header match rule specified header \"header2\" to range match of [0, 10],   :ref:`invert_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match\u003e`   is set to true and :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to false; The \"header2\" header is not present and the header   matcher rule for \"header2\" will be ignored so it will not match. * The header match rule specified header \"header3\" to a string regex match   ``^$`` which means an empty string, and   :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to true; The \"header3\" header is not present.   The match rule will treat the \"header3\" header as an empty header so it will match. * The header match rule specified header \"header4\" to a string regex match   ``^$`` which means an empty string, and   :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to false; The \"header4\" header is not present.   The match rule for \"header4\" will be ignored so it will not match."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Matcher",
            "description": ".. attention::   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1 ``Host``   header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead. .. attention::   To route on HTTP method, use the special HTTP/2 ``:method`` header. This works for both   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,   .. code-block:: json     {       \"name\": \":method\",       \"string_match\": {         \"exact\": \"POST\"       }     } .. attention::   In the absence of any header match specifier, match will default to :ref:`present_match   \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.present_match\u003e`. i.e, a request that has the :ref:`name   \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.name\u003e` header will match, regardless of the header's   value.  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.] [#next-free-field: 15]"
        },
        "envoy.type.matcher.v3.DoubleMatcher": {
            "properties": {
                "range": {
                    "$ref": "#/definitions/envoy.type.v3.DoubleRange",
                    "additionalProperties": true,
                    "description": "If specified, the input double value must be in the range specified here. Note: The range is using half-open interval semantics [start, end)."
                },
                "exact": {
                    "type": "number",
                    "description": "If specified, the input double value must be equal to the value specified here."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Number matcher]",
            "description": "[#protodoc-title: Number matcher]  Specifies the way to match a double value."
        },
        "envoy.type.matcher.v3.ListMatcher": {
            "properties": {
                "one_of": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher",
                    "additionalProperties": true,
                    "description": "If specified, at least one of the values in the list must match the value specified."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "List Matcher",
            "description": "Specifies the way to match a list value."
        },
        "envoy.type.matcher.v3.MetadataMatcher": {
            "properties": {
                "filter": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The filter name to retrieve the Struct from the Metadata."
                },
                "path": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.MetadataMatcher.PathSegment"
                    },
                    "type": "array",
                    "description": "The path to retrieve the Value from the Struct."
                },
                "value": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher",
                    "additionalProperties": true,
                    "description": "The MetadataMatcher is matched if the value retrieved by path is matched to this value."
                },
                "invert": {
                    "type": "boolean",
                    "description": "If true, the match result will be inverted."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "MetadataMatcher provides a general interface to check if a given value is matched in\n :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. It uses `filter` and `path` to retrieve the value\n from the Metadata and then check if it's matched to the specified value.\n\n For example, for the following Metadata:\n\n .. code-block:: yaml\n\n    filter_metadata:\n      envoy.filters.http.rbac:\n        fields:\n          a:\n            struct_value:\n              fields:\n                b:\n                  struct_value:\n                    fields:\n                      c:\n                        string_value: pro\n                t:\n                  list_value:\n                    values:\n                      - string_value: m\n                      - string_value: n\n\n The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value \"pro\"\n from the Metadata which is matched to the specified prefix match.\n\n .. code-block:: yaml\n\n    filter: envoy.filters.http.rbac\n    path:\n    - key: a\n    - key: b\n    - key: c\n    value:\n      string_match:\n        prefix: pr\n\n The following MetadataMatcher is matched as the code will match one of the string values in the\n list at the path [a, t].\n\n .. code-block:: yaml\n\n    filter: envoy.filters.http.rbac\n    path:\n    - key: a\n    - key: t\n    value:\n      list_match:\n        one_of:\n          string_match:\n            exact: m\n\n An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to\n enforce access control based on dynamic metadata in a request. See :ref:`Permission\n \u003cenvoy_v3_api_msg_config.rbac.v3.Permission\u003e` and :ref:`Principal\n \u003cenvoy_v3_api_msg_config.rbac.v3.Principal\u003e`.",
            "description": "[#protodoc-title: Metadata matcher]  MetadataMatcher provides a general interface to check if a given value is matched in :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. It uses `filter` and `path` to retrieve the value from the Metadata and then check if it's matched to the specified value. For example, for the following Metadata: .. code-block:: yaml    filter_metadata:      envoy.filters.http.rbac:        fields:          a:            struct_value:              fields:                b:                  struct_value:                    fields:                      c:                        string_value: pro                t:                  list_value:                    values:                      - string_value: m                      - string_value: n The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value \"pro\" from the Metadata which is matched to the specified prefix match. .. code-block:: yaml    filter: envoy.filters.http.rbac    path:    - key: a    - key: b    - key: c    value:      string_match:        prefix: pr The following MetadataMatcher is matched as the code will match one of the string values in the list at the path [a, t]. .. code-block:: yaml    filter: envoy.filters.http.rbac    path:    - key: a    - key: t    value:      list_match:        one_of:          string_match:            exact: m An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to enforce access control based on dynamic metadata in a request. See :ref:`Permission \u003cenvoy_v3_api_msg_config.rbac.v3.Permission\u003e` and :ref:`Principal \u003cenvoy_v3_api_msg_config.rbac.v3.Principal\u003e`.  [#next-major-version: MetadataMatcher should use StructMatcher]"
        },
        "envoy.type.matcher.v3.MetadataMatcher.PathSegment": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, use the key to retrieve the value in a Struct."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Path Segment",
            "description": "Specifies the segment in a path to retrieve value from Metadata. Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that if the segment key refers to a list, it has to be the last segment in a path."
        },
        "envoy.type.matcher.v3.OrMatcher": {
            "properties": {
                "value_matchers": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Or Matcher",
            "description": "Specifies a list of alternatives for the match."
        },
        "envoy.type.matcher.v3.RegexMatcher": {
            "properties": {
                "google_re2": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher.GoogleRE2",
                    "additionalProperties": true,
                    "description": "Google's RE2 regex engine."
                },
                "regex": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The regex match string. The string must be supported by the configured engine. The regex is matched against the full string, not as a partial match."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Regex matcher]",
            "description": "[#protodoc-title: Regex matcher]  A regex matcher designed for safety when used with untrusted input."
        },
        "envoy.type.matcher.v3.RegexMatcher.GoogleRE2": {
            "properties": {
                "max_program_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "This field controls the RE2 \"program size\" which is a rough estimate of how complex a compiled regex is to evaluate. A regex that has a program size greater than the configured value will fail to compile. In this case, the configured max program size can be increased or the regex can be simplified. If not specified, the default is 100. This field is deprecated; regexp validation should be performed on the management server instead of being done by each individual client. .. note::  Although this field is deprecated, the program size will still be checked against the  global ``re2.max_program_size.error_level`` runtime value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Google RE 2",
            "description": "Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ regex engine. The regex string must adhere to the documented `syntax \u003chttps://github.com/google/re2/wiki/Syntax\u003e`_. The engine is designed to complete execution in linear time as well as limit the amount of memory used. Envoy supports program size checking via runtime. The runtime keys ``re2.max_program_size.error_level`` and ``re2.max_program_size.warn_level`` can be set to integers as the maximum program size or complexity that a compiled regex can have before an exception is thrown or a warning is logged, respectively. ``re2.max_program_size.error_level`` defaults to 100, and ``re2.max_program_size.warn_level`` has no default if unset (will not check/log a warning). Envoy emits two stats for tracking the program size of regexes: the histogram ``re2.program_size``, which records the program size, and the counter ``re2.exceeded_warn_level``, which is incremented each time the program size exceeds the warn level threshold."
        },
        "envoy.type.matcher.v3.StringMatcher": {
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "The input string must match exactly the string specified here. Examples: * ``abc`` only matches the value ``abc``."
                },
                "prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``abc.xyz``"
                },
                "suffix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``xyz.abc``"
                },
                "safe_regex": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "The input string must match the regular expression specified here."
                },
                "contains": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``xyz.abc.def``"
                },
                "custom": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Use an extension as the matcher type. [#extension-category: envoy.string_matcher]"
                },
                "ignore_case": {
                    "type": "boolean",
                    "description": "If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. This has no effect for the safe_regex match. For example, the matcher ``data`` will match both input string ``Data`` and ``data`` if set to true."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: String matcher]",
            "description": "[#protodoc-title: String matcher]  Specifies the way to match a string. [#next-free-field: 9]"
        },
        "envoy.type.matcher.v3.ValueMatcher": {
            "properties": {
                "null_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher.NullMatch",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a NullValue."
                },
                "double_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.DoubleMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a double value and is matched to this field."
                },
                "string_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a string value and is matched to this field."
                },
                "bool_match": {
                    "type": "boolean",
                    "description": "If specified, a match occurs if and only if the target value is a bool value and is equal to this field."
                },
                "present_match": {
                    "type": "boolean",
                    "description": "If specified, value match will be performed based on whether the path is referring to a valid primitive value in the metadata. If the path is referring to a non-primitive value, the result is always not matched."
                },
                "list_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ListMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a list value and is matched to this field."
                },
                "or_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.OrMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if any of the alternatives in the match accept the value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Value matcher]",
            "description": "[#protodoc-title: Value matcher]  Specifies the way to match a ProtobufWkt::Value. Primitive values and ListValue are supported. StructValue is not supported and is always not matched. [#next-free-field: 8]"
        },
        "envoy.type.matcher.v3.ValueMatcher.NullMatch": {
            "additionalProperties": true,
            "type": "object",
            "title": "Null Match",
            "description": "NullMatch is an empty message to specify a null value."
        },
        "envoy.type.v3.DoubleRange": {
            "properties": {
                "start": {
                    "type": "number",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "number",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Double Range",
            "description": "Specifies the double start and end of the range using half-open interval semantics [start, end)."
        },
        "envoy.type.v3.FractionalPercent": {
            "properties": {
                "numerator": {
                    "type": "integer",
                    "description": "Specifies the numerator. Defaults to 0."
                },
                "denominator": {
                    "enum": [
                        "HUNDRED",
                        0,
                        "TEN_THOUSAND",
                        1,
                        "MILLION",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Denominator Type",
                    "description": "Fraction percentages support several fixed denominator values."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Fractional Percent",
            "description": "A fractional percentage is used in cases in which for performance reasons performing floating point to integer conversions during randomness calculations is undesirable. The message includes both a numerator and denominator that together determine the final fractional value. * **Example**: 1/100 = 1%. * **Example**: 3/10000 = 0.03%."
        },
        "envoy.type.v3.Int32Range": {
            "properties": {
                "start": {
                    "type": "integer",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "integer",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Int 32 Range",
            "description": "Specifies the int32 start and end of the range using half-open interval semantics [start, end)."
        },
        "envoy.type.v3.Int64Range": {
            "properties": {
                "start": {
                    "type": "string",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "string",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Range]",
            "description": "[#protodoc-title: Range]  Specifies the int64 start and end of the range using half-open interval semantics [start, end)."
        },
        "xds.core.v3.Authority": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Authority",
            "description": "xDS authority information."
        },
        "xds.core.v3.TypedExtensionConfig": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of an extension. This is not used to select the extension, instead it serves the role of an opaque identifier."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The typed config for the extension. The type URL will be used to identify the extension. In the case that the type URL is *xds.type.v3.TypedStruct* (or, for historical reasons, *udpa.type.v1.TypedStruct*), the inner type URL of *TypedStruct* will be utilized. See the :ref:`extension configuration overview \u003cconfig_overview_extension_configuration\u003e` for further details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Typed Extension Config",
            "description": "Message type for extension configuration."
        },
        "xds.type.matcher.v3.Matcher": {
            "properties": {
                "matcher_list": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList",
                    "additionalProperties": true,
                    "description": "A linear list of matchers to evaluate."
                },
                "matcher_tree": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherTree",
                    "additionalProperties": true,
                    "description": "A match tree to evaluate."
                },
                "on_no_match": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.OnMatch",
                    "additionalProperties": true,
                    "description": "Optional OnMatch to use if no matcher above matched (e.g., if there are no matchers specified above, or if none of the matches specified above succeeded). If no matcher above matched and this field is not populated, the match will be considered unsuccessful."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Unified Matcher API]",
            "description": "[#protodoc-title: Unified Matcher API]  A matcher, which may traverse a matching tree in order to result in a match action. During matching, the tree will be traversed until a match is found, or if no match is found the action specified by the most specific on_no_match will be evaluated. As an on_no_match might result in another matching tree being evaluated, this process might repeat several times until the final OnMatch (or no match) is decided."
        },
        "xds.type.matcher.v3.Matcher.MatcherList": {
            "properties": {
                "matchers": {
                    "items": {
                        "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.FieldMatcher"
                    },
                    "type": "array",
                    "description": "A list of matchers. First match wins."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Matcher List",
            "description": "A linear list of field matchers. The field matchers are evaluated in order, and the first match wins."
        },
        "xds.type.matcher.v3.Matcher.MatcherList.FieldMatcher": {
            "properties": {
                "predicate": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate",
                    "additionalProperties": true,
                    "description": "Determines if the match succeeds."
                },
                "on_match": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.OnMatch",
                    "additionalProperties": true,
                    "description": "What to do if the match succeeds."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Field Matcher",
            "description": "An individual matcher."
        },
        "xds.type.matcher.v3.Matcher.MatcherList.Predicate": {
            "properties": {
                "single_predicate": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate",
                    "additionalProperties": true,
                    "description": "A single predicate to evaluate."
                },
                "or_matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList",
                    "additionalProperties": true,
                    "description": "A list of predicates to be OR-ed together."
                },
                "and_matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList",
                    "additionalProperties": true,
                    "description": "A list of predicates to be AND-ed together."
                },
                "not_matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate",
                    "additionalProperties": true,
                    "description": "The invert of a predicate"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Predicate",
            "description": "Predicate to determine if a match is successful."
        },
        "xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList": {
            "properties": {
                "predicate": {
                    "items": {
                        "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Predicate List",
            "description": "A list of two or more matchers. Used to allow using a list within a oneof."
        },
        "xds.type.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate": {
            "properties": {
                "input": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Protocol-specific specification of input field to match on. [#extension-category: envoy.matching.common_inputs]"
                },
                "value_match": {
                    "$ref": "#/definitions/xds.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "Built-in string matcher."
                },
                "custom_match": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Extension for custom matching logic. [#extension-category: envoy.matching.input_matchers]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Single Predicate",
            "description": "Predicate for a single input field."
        },
        "xds.type.matcher.v3.Matcher.MatcherTree": {
            "properties": {
                "input": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Protocol-specific specification of input field to match on."
                },
                "exact_match_map": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherTree.MatchMap",
                    "additionalProperties": true
                },
                "prefix_match_map": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherTree.MatchMap",
                    "additionalProperties": true,
                    "description": "Longest matching prefix wins."
                },
                "custom_match": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Extension for custom matching logic."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Matcher Tree"
        },
        "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap": {
            "properties": {
                "map": {
                    "additionalProperties": {
                        "$ref": "#/definitions/xds.type.matcher.v3.Matcher.OnMatch",
                        "additionalProperties": true
                    },
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Match Map",
            "description": "A map of configured matchers. Used to allow using a map within a oneof."
        },
        "xds.type.matcher.v3.Matcher.OnMatch": {
            "properties": {
                "matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher",
                    "additionalProperties": true,
                    "description": "Nested matcher to evaluate. If the nested matcher does not match and does not specify on_no_match, then this matcher is considered not to have matched, even if a predicate at this level or above returned true."
                },
                "action": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Protocol-specific action to take."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "On Match",
            "description": "What to do if a match is successful."
        },
        "xds.type.matcher.v3.RegexMatcher": {
            "properties": {
                "google_re2": {
                    "$ref": "#/definitions/xds.type.matcher.v3.RegexMatcher.GoogleRE2",
                    "additionalProperties": true,
                    "description": "Google's RE2 regex engine."
                },
                "regex": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The regex match string. The string must be supported by the configured engine."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Regex matcher]",
            "description": "[#protodoc-title: Regex matcher]  A regex matcher designed for safety when used with untrusted input."
        },
        "xds.type.matcher.v3.RegexMatcher.GoogleRE2": {
            "additionalProperties": true,
            "type": "object",
            "title": "Google RE 2",
            "description": "Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ regex engine. The regex string must adhere to the documented `syntax \u003chttps://github.com/google/re2/wiki/Syntax\u003e`_. The engine is designed to complete execution in linear time as well as limit the amount of memory used. Envoy supports program size checking via runtime. The runtime keys `re2.max_program_size.error_level` and `re2.max_program_size.warn_level` can be set to integers as the maximum program size or complexity that a compiled regex can have before an exception is thrown or a warning is logged, respectively. `re2.max_program_size.error_level` defaults to 100, and `re2.max_program_size.warn_level` has no default if unset (will not check/log a warning). Envoy emits two stats for tracking the program size of regexes: the histogram `re2.program_size`, which records the program size, and the counter `re2.exceeded_warn_level`, which is incremented each time the program size exceeds the warn level threshold."
        },
        "xds.type.matcher.v3.StringMatcher": {
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "The input string must match exactly the string specified here. Examples: * *abc* only matches the value *abc*."
                },
                "prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * *abc* matches the value *abc.xyz*"
                },
                "suffix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * *abc* matches the value *xyz.abc*"
                },
                "safe_regex": {
                    "$ref": "#/definitions/xds.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "The input string must match the regular expression specified here."
                },
                "contains": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead. Examples: * *abc* matches the value *xyz.abc.def*"
                },
                "custom": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Use an extension as the matcher type. [#extension-category: envoy.string_matcher]"
                },
                "ignore_case": {
                    "type": "boolean",
                    "description": "If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no effect for the safe_regex match. For example, the matcher *data* will match both input string *Data* and *data* if set to true."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: String matcher]",
            "description": "[#protodoc-title: String matcher]  Specifies the way to match a string. [#next-free-field: 9]"
        }
    }
}